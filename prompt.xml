./index.html
---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio Drive</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="game-container">
      <canvas id="gameCanvas"></canvas>
    </div>
    <!-- Core Dependencies -->
    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/palettes.js"></script>
    <script src="js/font.js"></script>

    <!-- Game Modules -->
    <script src="js/effects/particle.js"></script>
    <script src="js/effects/effects.manager.js"></script>
    <script src="js/input.js"></script>

    <!-- Player -->
    <script src="js/player/player.renderer.js"></script>
    <script src="js/player/player.js"></script>

    <!-- World -->
    <script src="js/world/renderer.js"></script>
    <script src="js/world/generators.js"></script>
    <script src="js/world/themes.js"></script>
    <script src="js/world/parallax.js"></script>
    <script src="js/world/world.js"></script>

    <!-- Stops -->
    <script src="js/stops/stops.renderer.js"></script>
    <script src="js/stops/stops.manager.js"></script>

    <!-- UI -->
    <script src="js/ui/ui.renderer.js"></script>
    <script src="js/ui/ui.js"></script>

    <!-- Main Game Loop -->
    <script src="js/main.js"></script>
  </body>
</html>


---
./stops.js
---
// stops.js: Stop logic and data
const Stops = {
  stops: [
    {
      id: "ai-game",
      worldX: 350,
      theme: "gaming",
      linkURL: "https://your-ai-game-project-link.com",
      promptText: "Press [F] to Explore AI Game Project",
      marker: function (ctx, x, y) {
        drawArcadeCabinet(ctx, x, y);
      },
    },
    {
      id: "ai-ta",
      worldX: 1200,
      theme: "futuristic",
      linkURL: "https://your-english-ai-ta-link.com",
      promptText: "Press [F] to Explore English AI TA Project",
      marker: function (ctx, x, y) {
        drawHolographicTerminal(ctx, x, y);
      },
    },
    {
      id: "truck-parts",
      worldX: 2200,
      theme: "industrial",
      linkURL: "https://your-truck-parts-link.com",
      promptText: "Press [F] to Explore Truck Parts Project",
      marker: function (ctx, x, y) {
        drawWarehouse(ctx, x, y);
      },
    },
  ],
  activeStop: null,
  activationRadius: 60,
  update(dt, keys) {
    // Detect if player is near a stop
    this.activeStop = null;
    for (const stop of this.stops) {
      if (Math.abs(Player.x - stop.worldX) < this.activationRadius) {
        this.activeStop = stop;
        // Interaction
        if (keys["Enter"] || keys["Space"] || keys["KeyF"]) {
          window.open(stop.linkURL, "_blank");
          // Prevent repeated triggers
          keys["Enter"] = keys["Space"] = keys["KeyF"] = false;
        }
        break;
      }
    }
  },
  render(ctx) {
    // Draw stop markers in world
    for (const stop of this.stops) {
      // Convert worldX to screen X (relative to player)
      const screenX = CONFIG.CANVAS_WIDTH / 2 + (stop.worldX - Player.x);
      const markerY = CONFIG.CAR_START_Y - 40;
      if (screenX > -40 && screenX < CONFIG.CANVAS_WIDTH + 40) {
        stop.marker(ctx, screenX, markerY);
      }
    }
  },
};


---
./style.css
---
body {
  margin: 0;
  background-color: #333;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: "Courier New", Courier, monospace; /* Pixel-friendly font */
}

#game-container {
  border: 2px solid #555;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
  /* Dimensions will be set by JavaScript based on config */
}

canvas {
  display: block; /* Removes extra space below canvas */
  image-rendering: pixelated; /* Ensures crisp pixels */
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

/* Example for a custom pixel font if loaded via CSS */
/*
  @font-face {
    font-family: 'MyPixelFont';
    src: url('path/to/your/pixel-font.ttf') format('truetype');
  }
  */


---
./world.js
---
// world.js: Background, parallax, zones
const World = {
  parallaxLayers: [
    { speed: 0.2, color: "#7ec0ee" }, // sky
    { speed: 0.5, color: "#b0b0b0" }, // far
    { speed: 0.8, color: "#5c4033" }, // mid
  ],
  update(dt, keys) {
    // No-op for now; world scrolls based on Player.x
  },
  render(ctx) {
    // Determine current zone for visuals
    let zone =
      CONFIG.ZONES.find((z) => Player.x >= z.start && Player.x < z.end) ||
      CONFIG.ZONES[0];
    // Parallax background
    for (let i = 0; i < this.parallaxLayers.length; i++) {
      const layer = this.parallaxLayers[i];
      const scrollX = Player.x * layer.speed;
      ctx.save();
      // Sky layer (fill whole bg)
      if (i === 0) {
        ctx.fillStyle = layer.color;
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        // Clouds (all zones)
        for (let c = 0; c < 4; c++) {
          let cx =
            ((c * 320 - scrollX * 0.5) % (CONFIG.CANVAS_WIDTH + 320)) - 80;
          let cy = 60 + 30 * c;
          drawPixelCloud(ctx, cx, cy, 1 + 0.2 * (c % 2));
        }
      } else if (i === 1) {
        // Far background: zone-specific
        if (zone.name === "Gaming District") {
          // Blocky terrain, distant castle
          for (let x = -100; x < CONFIG.CANVAS_WIDTH + 100; x += 120) {
            let offset = (x - scrollX) % 240;
            drawPixelBlock(
              ctx,
              offset,
              CONFIG.CANVAS_HEIGHT - 120,
              100,
              40,
              "#7c5c2e"
            );
          }
          // Distant "castle"
          drawPixelBlock(
            ctx,
            200 - scrollX * 0.7,
            CONFIG.CANVAS_HEIGHT - 180,
            40,
            60,
            "#bcbcbc"
          );
        } else if (zone.name === "Neo-City Outskirts") {
          // Futuristic cityscape
          drawFuturisticCity(
            ctx,
            100 - scrollX * 0.7,
            CONFIG.CANVAS_HEIGHT - 120,
            300,
            80
          );
        } else {
          // Industrial: factories
          for (let x = -100; x < CONFIG.CANVAS_WIDTH + 100; x += 180) {
            let offset = (x - scrollX) % 360;
            drawFactory(ctx, offset, CONFIG.CANVAS_HEIGHT - 120, 80, 60);
          }
        }
      } else if (i === 2) {
        // Midground: zone-specific
        if (zone.name === "Gaming District") {
          // Trees
          for (let x = -60; x < CONFIG.CANVAS_WIDTH + 60; x += 90) {
            let offset = (x - scrollX) % 180;
            drawPixelTree(ctx, offset, CONFIG.CANVAS_HEIGHT - 80, 1);
          }
        } else if (zone.name === "Neo-City Outskirts") {
          // Glowing geometric shapes
          for (let x = -60; x < CONFIG.CANVAS_WIDTH + 60; x += 120) {
            let offset = (x - scrollX) % 240;
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = "#0ff";
            ctx.fillRect(offset, CONFIG.CANVAS_HEIGHT - 80, 40, 40);
            ctx.restore();
          }
        } else {
          // Industrial: trucks, warehouses
          for (let x = -60; x < CONFIG.CANVAS_WIDTH + 60; x += 160) {
            let offset = (x - scrollX) % 320;
            drawWarehouse(ctx, offset, CONFIG.CANVAS_HEIGHT - 64);
            drawTruck(ctx, offset + 40, CONFIG.CANVAS_HEIGHT - 44, 0.7);
          }
        }
      }
      ctx.restore();
    }
  },
};


---
./js/config.js
---
// js/config.js
const Config = {
  CANVAS_WIDTH: 800,
  CANVAS_HEIGHT: 600,
  TARGET_FPS: 60,
  KeyBindings: {
    MOVE_LEFT: ["ArrowLeft", "a", "A"],
    MOVE_RIGHT: ["ArrowRight", "d", "D"],
    INTERACT: ["Enter", " ", "f", "F"],
    TOGGLE_HEADLIGHTS: ["h", "H"], // Added for headlights
  },
  DEBUG_MODE: false, // Set to true for debug info
  STOP_LINKS: {
    project_ai_game: "https://example.com/ai-game-project",
    project_ai_ta: "https://example.com/ai-ta-project",
    project_truck_parts: "https://example.com/truck-parts-project",
  },
  PLAYER_DUST_EMIT_THRESHOLD: 1.0,
  PLAYER_EXHAUST_EMIT_THRESHOLD: 0.5,
  PLAYER_SPEED_LINE_THRESHOLD: 5.0,
  MAX_DUST_PARTICLES_PER_FRAME: 2,
  MAX_EXHAUST_PARTICLES_PER_FRAME: 1,
  MAX_SPEED_LINES_PER_FRAME: 3,
  UI_TYPEWRITER_SPEED: 3, // characters per second (approx, tied to frames)
  UI_PANEL_INTRO_SPEED: 15, // pixels per frame
};


---
./js/font.js
---
// js/font.js

// I.1.C Custom Pixel Font (Bitmap Font simulation)
function drawPixelText(
  ctx,
  text,
  startX,
  startY,
  color,
  scale = 1,
  customFontSettings = PixelFontData.fontSettings
) {
  ctx.fillStyle = color;
  let currentX = startX;
  const charHeight = customFontSettings.charHeight * scale;

  for (let char of text.toUpperCase()) {
    // Assuming font data is uppercase
    const charData = PixelFontData[char] || PixelFontData["?"]; // Fallback to '?'
    const charWidth =
      (charData[0] ? charData[0].length : PixelFontData.DEFAULT_CHAR_WIDTH) *
      scale;

    if (char === " ") {
      currentX +=
        PixelFontData.DEFAULT_CHAR_WIDTH * scale +
        customFontSettings.charSpacing * scale;
      continue;
    }

    for (let r = 0; r < charData.length; r++) {
      for (let c = 0; c < charData[r].length; c++) {
        if (charData[r][c] === 1) {
          drawPixelRect(
            ctx,
            currentX + c * scale,
            startY + r * scale,
            scale,
            scale,
            color
          );
        }
      }
    }
    currentX += charWidth + customFontSettings.charSpacing * scale;
  }
  return currentX; // Return end X for potential chaining
}

const PixelFontData = {
  fontSettings: {
    charHeight: 5,
    charSpacing: 1,
    lineHeight: 7,
  },
  A: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 1, 1, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
  ],
  B: [
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 1, 1, 0],
  ],
  C: [
    [0, 1, 1, 1],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
    [0, 1, 1, 1],
  ],
  D: [
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 1, 1, 0],
  ],
  E: [
    [1, 1, 1, 1],
    [1, 0, 0, 0],
    [1, 1, 1, 0],
    [1, 0, 0, 0],
    [1, 1, 1, 1],
  ],
  F: [
    [1, 1, 1, 1],
    [1, 0, 0, 0],
    [1, 1, 1, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
  ],
  G: [
    [0, 1, 1, 1],
    [1, 0, 0, 0],
    [1, 0, 1, 1],
    [1, 0, 0, 1],
    [0, 1, 1, 1],
  ],
  H: [
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 1, 1, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
  ],
  I: [
    [1, 1, 1],
    [0, 1, 0],
    [0, 1, 0],
    [0, 1, 0],
    [1, 1, 1],
  ],
  J: [
    [0, 0, 1, 1],
    [0, 0, 0, 1],
    [0, 0, 0, 1],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  K: [
    [1, 0, 0, 1],
    [1, 0, 1, 0],
    [1, 1, 0, 0],
    [1, 0, 1, 0],
    [1, 0, 0, 1],
  ],
  L: [
    [1, 0, 0, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
    [1, 1, 1, 1],
  ],
  M: [
    [1, 0, 0, 0, 1],
    [1, 1, 0, 1, 1],
    [1, 0, 1, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
  ],
  N: [
    [1, 0, 0, 1],
    [1, 1, 0, 1],
    [1, 0, 1, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
  ],
  O: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  P: [
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 1, 1, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0],
  ],
  Q: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 0, 1, 1],
    [0, 1, 1, 1],
  ],
  R: [
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 1, 1, 0],
    [1, 0, 1, 0],
    [1, 0, 0, 1],
  ],
  S: [
    [0, 1, 1, 1],
    [1, 0, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 1, 0],
  ],
  T: [
    [1, 1, 1, 1, 1],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
  ],
  U: [
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  V: [
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 1, 0, 0],
  ],
  W: [
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 1, 0, 1],
    [1, 1, 0, 1, 1],
    [1, 0, 0, 0, 1],
  ],
  X: [
    [1, 0, 0, 1],
    [0, 1, 1, 0],
    [0, 0, 1, 0],
    [0, 1, 1, 0],
    [1, 0, 0, 1],
  ],
  Y: [
    [1, 0, 1],
    [1, 0, 1],
    [0, 1, 0],
    [0, 1, 0],
    [0, 1, 0],
  ],
  Z: [
    [1, 1, 1, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [1, 0, 0, 0],
    [1, 1, 1, 1],
  ],
  0: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 0],
  ],
  1: [
    [0, 1, 0],
    [1, 1, 0],
    [0, 1, 0],
    [0, 1, 0],
    [1, 1, 1],
  ],
  2: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [1, 1, 1, 1],
  ],
  3: [
    [1, 1, 1, 0],
    [0, 0, 0, 1],
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 1, 0],
  ],
  4: [
    [0, 0, 1, 0],
    [0, 1, 1, 0],
    [1, 0, 1, 0],
    [1, 1, 1, 1],
    [0, 0, 1, 0],
  ],
  5: [
    [1, 1, 1, 1],
    [1, 0, 0, 0],
    [1, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 1, 0],
  ],
  6: [
    [0, 1, 1, 0],
    [1, 0, 0, 0],
    [1, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  7: [
    [1, 1, 1, 1],
    [0, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 1, 0, 0],
  ],
  8: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  9: [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 1, 1],
    [0, 0, 0, 1],
    [0, 1, 1, 0],
  ],
  " ": [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
  ],
  ".": [[0], [0], [0], [0], [1]],
  ",": [
    [0, 0],
    [0, 0],
    [0, 0],
    [1, 0],
    [0, 1],
  ],
  "!": [[1], [1], [1], [0], [1]],
  "?": [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
  ],
  "-": [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [1, 1, 1, 1],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
  ],
  ":": [[0], [1], [0], [1], [0]],
  "[": [
    [1, 1, 0],
    [1, 0, 0],
    [1, 0, 0],
    [1, 0, 0],
    [1, 1, 0],
  ],
  "]": [
    [0, 1, 1],
    [0, 0, 1],
    [0, 0, 1],
    [0, 0, 1],
    [0, 1, 1],
  ],
  DEFAULT_CHAR_WIDTH: 4,
  DEFAULT_CHAR_HEIGHT: 5,
};


---
./js/input.js
---
// js/input.js
const Input = {
  keys: {},
  lastPressed: {}, // For detecting single presses
  init() {
    window.addEventListener("keydown", (e) => this.handleKeyDown(e));
    window.addEventListener("keyup", (e) => this.handleKeyUp(e));
    if (Config.DEBUG_MODE) console.log("Input system initialized.");
  },
  handleKeyDown(e) {
    if (!this.keys[e.key]) {
      // Only set lastPressed on initial press
      this.lastPressed[e.key] = true;
    }
    this.keys[e.key] = true;
  },
  handleKeyUp(e) {
    this.keys[e.key] = false;
    this.lastPressed[e.key] = false; // Clear lastPressed on key up
  },
  isPressed(action) {
    const boundKeys = Config.KeyBindings[action];
    if (boundKeys) {
      return boundKeys.some((key) => this.keys[key]);
    }
    return false;
  },
  isJustPressed(action) {
    const boundKeys = Config.KeyBindings[action];
    if (boundKeys) {
      for (const key of boundKeys) {
        if (this.keys[key] && this.lastPressed[key]) {
          this.lastPressed[key] = false; // Consume the "just pressed" state
          return true;
        }
      }
    }
    return false;
  },
  isMoveLeftPressed() {
    return this.isPressed("MOVE_LEFT");
  },
  isMoveRightPressed() {
    return this.isPressed("MOVE_RIGHT");
  },
  isInteractPressed() {
    // This will now be for continuous press if needed
    return this.isPressed("INTERACT");
  },
  isInteractJustPressed() {
    // For single action
    return this.isJustPressed("INTERACT");
  },
  isToggleHeadlightsJustPressed() {
    return this.isJustPressed("TOGGLE_HEADLIGHTS");
  },
};
Input.init();


---
./js/main.js
---
// js/main.js
class Game {
  constructor() {
    this.canvas = document.getElementById("gameCanvas");
    this.ctx = this.canvas.getContext("2d");
    this.lastTime = 0;
    this.gameTime = 0;
    this.deltaTime = 0;
    this.frameCount = 0;
    this.player = null;
    this.world = null;
    this.ui = null;
    this.init();
  }
  init() {
    this.canvas.width = Config.CANVAS_WIDTH;
    this.canvas.height = Config.CANVAS_HEIGHT;
    this.ctx.imageSmoothingEnabled = false;
    this.ctx.mozImageSmoothingEnabled = false;
    this.ctx.webkitImageSmoothingEnabled = false;
    this.ctx.msImageSmoothingEnabled = false;

    this.player = new Player(this);
    this.world = new World(this);
    this.ui = new UI(this);

    if (Config.DEBUG_MODE) {
      console.log(
        "Game initialized with Player, World, StopsManager, and UI ready."
      );
    }
    this.gameLoop = this.gameLoop.bind(this);
    requestAnimationFrame(this.gameLoop);
  }

  update(deltaTime) {
    this.player.update(deltaTime);
    const worldScrollSpeed = this.player.currentSpeed;
    this.world.update(worldScrollSpeed);
    StopsManager.update(
      this.world.worldX,
      this.player.screenX,
      this.player.width,
      this
    );
    this.ui.update(deltaTime);
    EffectsManager.update(deltaTime);
  }

  render() {
    this.ctx.clearRect(0, 0, Config.CANVAS_WIDTH, Config.CANVAS_HEIGHT);

    // 1. World background (sky, distant layers)
    this.world.render(this.ctx);

    // 2. Background weather particles (world-space)
    this.ctx.save();
    this.ctx.translate(-this.world.worldX, 0);
    EffectsManager.renderLayer(this.ctx, "weather_background");
    this.ctx.restore();

    // 3. Stop markers (world-space)
    StopsManager.render(
      this.ctx,
      this.world.worldX,
      this.world.groundLevelY,
      this.gameTime
    );

    // 4. Particles behind player (screen-space)
    EffectsManager.renderLayer(this.ctx, "behind_player");

    // 5. Player
    this.player.render(this.ctx);

    // 6. World foreground layers
    this.world.renderForeground(this.ctx);

    // 7. Foreground weather particles (world-space)
    this.ctx.save();
    this.ctx.translate(-this.world.worldX, 0);
    EffectsManager.renderLayer(this.ctx, "weather_foreground");
    this.ctx.restore();

    // 8. Screen-wide effects
    EffectsManager.drawVignette(this.ctx);
    EffectsManager.drawScanlines(this.ctx, this.world);

    // 9. UI
    this.ui.render(this.ctx);

    // 10. Debug Info
    if (Config.DEBUG_MODE) {
      const fpsText = `FPS: ${(1 / this.deltaTime).toFixed(0)}`;
      const gameTimeText = `GT: ${this.gameTime.toFixed(1)}s`;
      const particleCount = `PC: ${EffectsManager.particles.length}`;
      drawPixelText(this.ctx, fpsText, 10, 10, "white", 1.5);
      drawPixelText(this.ctx, gameTimeText, 10, 25, "white", 1.5);
      drawPixelText(this.ctx, particleCount, 10, 40, "white", 1.5);
    }
  }

  gameLoop(currentTime) {
    const now = performance.now();
    if (this.lastTime === 0) {
      this.lastTime = now;
    }
    this.deltaTime = (now - this.lastTime) / 1000;
    this.lastTime = now;

    this.gameTime += this.deltaTime;
    this.frameCount++;

    const maxDeltaTime = (1 / Config.TARGET_FPS) * 3;
    if (this.deltaTime > maxDeltaTime) {
      if (Config.DEBUG_MODE)
        console.warn(
          `DeltaTime capped from ${this.deltaTime.toFixed(
            4
          )} to ${maxDeltaTime.toFixed(4)}`
        );
      this.deltaTime = maxDeltaTime;
    }

    this.update(this.deltaTime);
    this.render();
    requestAnimationFrame(this.gameLoop);
  }
}

window.onload = () => {
  const game = new Game();
};


---
./js/palettes.js
---
// js/palettes.js
const Palettes = {
  vehicle: {
    CAR_BODY_MAIN: "#C0392B",
    CAR_BODY_ACCENT: "#E74C3C",
    CAR_WINDOW: "#7FB3D5",
    CAR_TIRE_DARK: "#2C3E50",
    CAR_TIRE_LIGHT: "#34495E",
    CAR_UNDERCARRIAGE: "#566573",
    CAR_ROOF: "#A93226",
    CAR_HEADLIGHT_ON: "#FFFFE0",
    CAR_HEADLIGHT_OFF: "#B0B0B0",
    CAR_TAILLIGHT_ON: "#FF0000",
    CAR_TAILLIGHT_BRAKE: "#FF4500",
    CAR_TAILLIGHT_OFF: "#8B0000",
    DUST_COLOR: ["#A0522D", "#8B4513", "#D2B48C"],
    EXHAUST_SMOKE: ["#555555", "#666666", "#777777"],
  },
  desert: {
    sky: ["#FAD7A0", "#F5B041", "#E6E6FA"], // Lightened Zenith
    ground: ["#D2B48C", "#C19A6B", "#A0522D" /*detail*/, "#8B4513" /*shadow*/],
    objects_primary: { base: "#B08D57", light: "#C8A165", shadow: "#967142" },
    objects_accent: ["#8B4513", "#F0E68C"],
    emissive: ["#FFBF00"],
    atmosphere: {
      hazeColor: "rgba(245, 176, 65, 0.08)",
      fogColor: "rgba(210, 180, 140, 0.03)",
    }, // Subtler
    generic_dust: ["#A0522D", "#8B4513", "#D2B48C"],
  },
  gaming: {
    sky: ["#5C94FC", "#3060E1"],
    ground: ["#34A245", "#2A8C39", "#83E270" /*detail*/, "#1F682A" /*shadow*/],
    objects_primary: { base: "#808080", light: "#A0A0A0", shadow: "#606060" },
    objects_accent: ["#FF00FF", "#00FF00"],
    emissive: ["#FFFF00", "#00FFFF", "#FF69B4"],
    props: ["#FF0000", "#FFFF00", "#00FF00", "#FF00FF"], // Ensured this is present
    atmosphere: {
      hazeColor: "rgba(48, 96, 225, 0.05)",
      fogColor: "rgba(0,0,0,0.0)",
    },
  },
  futuristic: {
    sky: ["#101020", "#202040", "#080810"],
    ground: [
      "#303038",
      "#282830",
      "#404050" /*lines/detail*/,
      "#181820" /*shadow*/,
    ],
    objects_primary: { base: "#A0A0C0", light: "#C0C0E0", shadow: "#707090" },
    objects_accent: ["#E0E0FF", "#00A0A0"],
    emissive: ["#00FFFF", "#FF00FF", "#FFFF00", "#7FFF00"],
    atmosphere: {
      hazeColor: "rgba(32, 32, 64, 0.12)",
      fogColor: "rgba(16, 16, 32, 0.15)",
    }, // Subtler
  },
  industrial: {
    sky: ["#778899", "#808080", "#607080"],
    ground: ["#606060", "#707070", "#505050" /*detail*/, "#404040" /*shadow*/],
    objects_primary: { base: "#6E6E6E", light: "#8C8C8C", shadow: "#545454" },
    objects_accent: ["#B7410E", "#A0522D"],
    emissive: ["#FFA500", "#FFD700"],
    atmosphere: {
      hazeColor: "rgba(100, 100, 100, 0.15)",
      fogColor: "rgba(80, 80, 80, 0.25)",
    }, // Subtler
    smoke: ["#A9A9A9", "#C0C0C0", "#D3D3D3"],
  },
  ui: {
    FRAME_DARK: "#202020",
    FRAME_LIGHT: "#505050",
    FRAME_HIGHLIGHT: "#707070",
    BUTTON_F_KEY_BG: "#4A4A4A",
    BUTTON_F_KEY_FG: "#E0E0E0",
    MINIMAP_PLAYER: "#00FF00",
    MINIMAP_STOP_DEFAULT: "#FFFF00",
    MINIMAP_STOP_GAMING: "#FF00FF",
    MINIMAP_STOP_FUTURISTIC: "#00FFFF",
    MINIMAP_STOP_INDUSTRIAL: "#FFA500",
    MINIMAP_TEXTURE: "rgba(0,0,0,0.2)",
  },
};


---
./js/utils.js
---
// js/utils.js
function drawPixelRect(ctx, x, y, width, height, color) {
  ctx.fillStyle = color;
  ctx.fillRect(
    Math.floor(x),
    Math.floor(y),
    Math.max(1, Math.floor(width)), // Ensure width/height is at least 1
    Math.max(1, Math.floor(height))
  );
}

function drawPixel(ctx, x, y, color, pixelSize = 1) {
  ctx.fillStyle = color;
  ctx.fillRect(
    Math.floor(x * pixelSize),
    Math.floor(y * pixelSize),
    pixelSize,
    pixelSize
  );
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

function getRandomColor(paletteArray) {
  if (
    !paletteArray ||
    !Array.isArray(paletteArray) ||
    paletteArray.length === 0
  ) {
    return "#000000";
  }
  return paletteArray[Math.floor(Math.random() * paletteArray.length)];
}

function lightenDarkenColor(hex, percent) {
  if (typeof hex !== "string") {
    return "#000000";
  }

  let usePound = false;
  if (hex.startsWith("#")) {
    hex = hex.slice(1);
    usePound = true;
  }
  if (hex.length === 3) {
    hex = hex
      .split("")
      .map((char) => char + char)
      .join("");
  }
  if (hex.length !== 6) {
    if (hex.toLowerCase().startsWith("rgba"))
      return (usePound ? "#" : "") + hex;
    return (usePound ? "#" : "") + "000000";
  }

  const num = parseInt(hex, 16);
  if (isNaN(num)) {
    return (usePound ? "#" : "") + "000000";
  }

  let r = (num >> 16) + percent;
  r = Math.max(0, Math.min(255, r));

  let g = ((num >> 8) & 0x00ff) + percent;
  g = Math.max(0, Math.min(255, g));

  let b = (num & 0x0000ff) + percent;
  b = Math.max(0, Math.min(255, b));

  const R = Math.round(r).toString(16).padStart(2, "0");
  const G = Math.round(g).toString(16).padStart(2, "0");
  const B = Math.round(b).toString(16).padStart(2, "0");

  return (usePound ? "#" : "") + R + G + B;
}

function desaturateColor(hex, amount) {
  if (typeof hex !== "string") {
    return "#000000";
  }

  let usePound = false;
  const originalHexInputForWarning = hex;

  if (hex.startsWith("#")) {
    hex = hex.slice(1);
    usePound = true;
  }
  if (hex.length === 3) {
    hex = hex
      .split("")
      .map((char) => char + char)
      .join("");
  }
  if (hex.length !== 6) {
    if (hex.toLowerCase().startsWith("rgba"))
      return (usePound ? "#" : "") + hex;
    return (usePound ? "#" : "") + "000000";
  }

  const num = parseInt(hex, 16);
  if (isNaN(num)) {
    return (usePound ? "#" : "") + "000000";
  }
  let r = num >> 16;
  let g = (num >> 8) & 0x00ff;
  let b = num & 0x0000ff;

  const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
  r = Math.round(r + (gray - r) * amount);
  g = Math.round(g + (gray - g) * amount);
  b = Math.round(b + (gray - b) * amount);

  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));

  const R = r.toString(16).padStart(2, "0");
  const G = g.toString(16).padStart(2, "0");
  const B = b.toString(16).padStart(2, "0");

  return (usePound ? "#" : "") + R + G + B;
}

function interpolateColor(hex1, hex2, factor) {
  if (typeof hex1 !== "string" || typeof hex2 !== "string") {
    return typeof hex2 === "string"
      ? hex2
      : typeof hex1 === "string"
      ? hex1
      : "#000000";
  }
  factor = Math.max(0, Math.min(1, factor));

  const parseHexComponent = (hexStr) => {
    let h = hexStr.startsWith("#") ? hexStr.slice(1) : hexStr;
    if (h.length === 3)
      h = h
        .split("")
        .map((c) => c + c)
        .join("");
    if (h.length !== 6) {
      return [0, 0, 0];
    }
    const r = parseInt(h.substring(0, 2), 16);
    const g = parseInt(h.substring(2, 4), 16);
    const b = parseInt(h.substring(4, 6), 16);
    if (isNaN(r) || isNaN(g) || isNaN(b)) return [0, 0, 0]; // Check for NaN after parsing
    return [r, g, b];
  };

  try {
    const [r1, g1, b1] = parseHexComponent(hex1);
    const [r2, g2, b2] = parseHexComponent(hex2);

    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);

    const componentToHex = (c) => {
      const hexVal = Math.max(0, Math.min(255, c)).toString(16);
      return hexVal.length === 1 ? "0" + hexVal : hexVal;
    };

    return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
  } catch (e) {
    return typeof hex2 === "string" && hex2.startsWith("#")
      ? hex2
      : typeof hex2 === "string"
      ? "#" + hex2
      : "#000000";
  }
}


---
./js/ui/ui.js
---
// js/ui/ui.js
class UI {
  constructor(game) {
    this.game = game;
    this.height = 60;
    this.yPosition = Config.CANVAS_HEIGHT - this.height;
    this.backgroundColor = "rgba(10, 20, 10, 0.85)";
    this.borderColor = Palettes.ui.FRAME_DARK;
    this.textColor = "#B0E0B0";

    this.fontSettings = {
      ...PixelFontData.fontSettings,
      scale: 2,
    };

    this.infoScreenWidth = 350;
    this.infoScreenHeight = 28;
    this.infoScreenX = (Config.CANVAS_WIDTH - this.infoScreenWidth) / 2;
    this.infoScreenY =
      this.yPosition + (this.height - this.infoScreenHeight) / 2 - 5;
    this.infoScreenColor = "rgba(20, 40, 20, 0.9)";
    this.infoScreenBorderColor = Palettes.ui.FRAME_LIGHT;

    this.displayedText = "";
    this.targetText = "";
    this.typewriterIndex = 0;
    this.typewriterFrameCounter = 0;

    this.panelYOffset = this.height;
    this.panelIntroSpeed = Config.UI_PANEL_INTRO_SPEED;

    this.fKeyIcon = UIRenderer.createFKeyIcon(this.fontSettings);

    this.showDriveInstruction = true; // To control visibility of the initial instruction

    if (Config.DEBUG_MODE) console.log("UI initialized.");
  }

  update(deltaTime) {
    // Hide the initial drive instruction once the player moves right
    if (this.showDriveInstruction && Input.isMoveRightPressed()) {
      this.showDriveInstruction = false;
    }

    if (this.panelYOffset > 0) {
      this.panelYOffset -= this.panelIntroSpeed * (60 * deltaTime);
      if (this.panelYOffset < 0) this.panelYOffset = 0;
    }

    const currentZone = StopsManager.getCurrentZone(this.game.world.worldX);
    let newTargetText = "Portfolio Drive";
    if (currentZone) {
      if (
        StopsManager.activeStop &&
        Config.STOP_LINKS[StopsManager.activeStop.id]
      ) {
        newTargetText = `${StopsManager.activeStop.promptText}`;
      } else if (currentZone.promptText) {
        newTargetText = currentZone.promptText;
      }
    }

    if (this.targetText !== newTargetText) {
      this.targetText = newTargetText;
      this.displayedText = "";
      this.typewriterIndex = 0;
      this.typewriterFrameCounter = 0;
    }

    if (this.typewriterIndex < this.targetText.length) {
      this.typewriterFrameCounter += 60 * deltaTime;
      const charsToAdvance = Math.floor(
        this.typewriterFrameCounter / Config.UI_TYPEWRITER_SPEED
      );
      if (charsToAdvance > 0) {
        this.typewriterIndex += charsToAdvance;
        this.typewriterFrameCounter %= Config.UI_TYPEWRITER_SPEED;
        this.displayedText = this.targetText.substring(0, this.typewriterIndex);
      }
    } else {
      this.displayedText = this.targetText;
    }
  }

  renderDriveInstruction(ctx) {
    const animOffset = ((Math.sin(this.game.gameTime * 6) + 1) / 2) * 8;
    const alpha = 0.75 + ((Math.sin(this.game.gameTime * 6) + 1) / 2) * 0.25;
    ctx.globalAlpha = alpha;

    const text = "USE RIGHT ARROW TO DRIVE";
    const textScale = 3;

    // Accurate text width calculation
    let textWidth = 0;
    for (let char of text.toUpperCase()) {
      const charData = PixelFontData[char] || PixelFontData["?"];
      textWidth +=
        (charData[0] ? charData[0].length : PixelFontData.DEFAULT_CHAR_WIDTH) *
        textScale;
      textWidth += PixelFontData.fontSettings.charSpacing * textScale;
    }
    textWidth -= PixelFontData.fontSettings.charSpacing * textScale;

    const arrowSize = 30;
    const padding = 20;

    const totalWidth = textWidth + padding + arrowSize;
    const startX = Config.CANVAS_WIDTH - totalWidth - 60;
    const startY = Config.CANVAS_HEIGHT / 2 - 50;

    const textY =
      startY +
      (arrowSize - PixelFontData.fontSettings.charHeight * textScale) / 2;
    drawPixelText(ctx, text, startX, textY, "#FFFFFF", textScale);

    const arrowX = startX + textWidth + padding + animOffset;
    const arrowY = startY + arrowSize / 2;
    UIRenderer.drawRightArrow(ctx, arrowX, arrowY, arrowSize, "#FFFFFF");

    ctx.globalAlpha = 1.0;
  }

  render(ctx) {
    const actualYPosition = this.yPosition + this.panelYOffset;

    drawPixelRect(
      ctx,
      0,
      actualYPosition,
      Config.CANVAS_WIDTH,
      this.height,
      this.backgroundColor
    );
    UIRenderer.drawPixelArtFrame(
      ctx,
      0,
      actualYPosition,
      Config.CANVAS_WIDTH,
      this.height
    );

    UIRenderer.drawPixelArtFrame(
      ctx,
      this.infoScreenX,
      actualYPosition + (this.height - this.infoScreenHeight) / 2 - 5,
      this.infoScreenWidth,
      this.infoScreenHeight
    );
    drawPixelRect(
      ctx,
      this.infoScreenX + 6,
      actualYPosition + (this.height - this.infoScreenHeight) / 2 - 5 + 6,
      this.infoScreenWidth - 12,
      this.infoScreenHeight - 12,
      this.infoScreenColor
    );

    const textY =
      actualYPosition +
      (this.height - this.infoScreenHeight) / 2 -
      5 +
      this.infoScreenHeight / 2 -
      (this.fontSettings.charHeight * this.fontSettings.scale) / 2;

    let textToRender = this.displayedText;
    let textWidth = 0;
    for (let char of textToRender.toUpperCase()) {
      const charData = PixelFontData[char] || PixelFontData["?"];
      textWidth +=
        (charData[0] ? charData[0].length : PixelFontData.DEFAULT_CHAR_WIDTH) *
        this.fontSettings.scale;
      textWidth += this.fontSettings.charSpacing * this.fontSettings.scale;
    }
    textWidth -= this.fontSettings.charSpacing * this.fontSettings.scale;

    const textStartX =
      this.infoScreenX + (this.infoScreenWidth - textWidth) / 2;

    let hasInteractivePromptThisFrame =
      StopsManager.activeStop &&
      Config.STOP_LINKS[StopsManager.activeStop.id] &&
      textToRender.includes("[F]");

    if (hasInteractivePromptThisFrame) {
      const fKeyIndex = textToRender.indexOf("[F]");
      const preText = textToRender.substring(0, fKeyIndex);
      const postText = textToRender.substring(fKeyIndex + 3);

      let currentX = drawPixelText(
        ctx,
        preText,
        textStartX,
        textY,
        this.textColor,
        this.fontSettings.scale,
        this.fontSettings
      );

      const iconY =
        textY -
        (this.fKeyIcon.height -
          this.fontSettings.charHeight * this.fontSettings.scale) /
          2;
      ctx.drawImage(this.fKeyIcon, currentX, iconY);
      currentX +=
        this.fKeyIcon.width +
        this.fontSettings.charSpacing * this.fontSettings.scale;

      drawPixelText(
        ctx,
        postText,
        currentX,
        textY,
        this.textColor,
        this.fontSettings.scale,
        this.fontSettings
      );
    } else {
      drawPixelText(
        ctx,
        textToRender,
        textStartX,
        textY,
        this.textColor,
        this.fontSettings.scale,
        this.fontSettings
      );
    }

    ctx.strokeStyle = "rgba(50, 100, 50, 0.1)";
    ctx.lineWidth = 1;
    const infoScreenActualY =
      actualYPosition + (this.height - this.infoScreenHeight) / 2 - 5;
    for (
      let i = 0;
      i < this.infoScreenHeight;
      i += 2 * this.fontSettings.scale
    ) {
      ctx.beginPath();
      ctx.moveTo(this.infoScreenX, infoScreenActualY + i + 0.5);
      ctx.lineTo(
        this.infoScreenX + this.infoScreenWidth,
        infoScreenActualY + i + 0.5
      );
      ctx.stroke();
    }

    UIRenderer.drawStatusLights(ctx, this, actualYPosition);
    UIRenderer.drawMiniMap(ctx, this, actualYPosition);

    // Render drive instruction if needed
    if (this.showDriveInstruction) {
      this.renderDriveInstruction(ctx);
    }
  }
}


---
./js/ui/ui.renderer.js
---
// js/ui/ui.renderer.js
const UIRenderer = {
  // I.1.C UI Elements: Frames
  drawPixelArtFrame(ctx, x, y, width, height, themeColors = Palettes.ui) {
    const outerDark = themeColors.FRAME_DARK || "#101010";
    const midLight = themeColors.FRAME_LIGHT || "#404040";
    const innerHighlight = themeColors.FRAME_HIGHLIGHT || "#606060";
    const thickness = 2; // Each band thickness

    drawPixelRect(ctx, x, y, width, height, outerDark);
    drawPixelRect(
      ctx,
      x + thickness,
      y + thickness,
      width - thickness * 2,
      height - thickness * 2,
      midLight
    );
    drawPixelRect(
      ctx,
      x + thickness * 2,
      y + thickness * 2,
      width - thickness * 4,
      height - thickness * 4,
      innerHighlight
    );
  },

  drawSimplePixelBorder(ctx, x, y, width, height, color, thickness = 1) {
    ctx.strokeStyle = color;
    ctx.lineWidth = thickness;
    for (let i = 0; i < thickness; i++) {
      ctx.strokeRect(
        Math.floor(x) + i + 0.5,
        Math.floor(y) + i + 0.5,
        Math.floor(width) - 1 - i * 2,
        Math.floor(height) - 1 - i * 2
      );
    }
  },

  createFKeyIcon(fontSettings) {
    const size = 8 * fontSettings.scale;
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    const s = fontSettings.scale;
    drawPixelRect(ctx, 0, 0, 8 * s, 8 * s, Palettes.ui.BUTTON_F_KEY_BG);
    drawPixelRect(
      ctx,
      1 * s,
      1 * s,
      6 * s,
      6 * s,
      lightenDarkenColor(Palettes.ui.BUTTON_F_KEY_BG, 20)
    );

    const fData = PixelFontData["F"];
    const charOffsetX = 2 * s;
    const charOffsetY = 1 * s;
    ctx.fillStyle = Palettes.ui.BUTTON_F_KEY_FG;
    for (let r = 0; r < fData.length; r++) {
      for (let c = 0; c < fData[r].length; c++) {
        if (fData[r][c] === 1) {
          drawPixelRect(
            ctx,
            charOffsetX + c * s,
            charOffsetY + r * s,
            s,
            s,
            Palettes.ui.BUTTON_F_KEY_FG
          );
        }
      }
    }
    return canvas;
  },

  drawRightArrow(ctx, x, y, size, color) {
    const s = Math.max(1, Math.floor(size / 6));
    const shaftWidth = s * 3;
    const shaftHeight = s * 2;

    // shaft
    drawPixelRect(ctx, x, y - shaftHeight / 2, shaftWidth, shaftHeight, color);

    // head
    const headStartX = x + shaftWidth;
    // Base of the arrow head (tallest part)
    drawPixelRect(ctx, headStartX, y - s * 3, s, s * 6, color);
    // Middle part
    drawPixelRect(ctx, headStartX + s, y - s * 2, s, s * 4, color);
    // Tip (pointy part)
    drawPixelRect(ctx, headStartX + s * 2, y - s, s, s * 2, color);
  },

  // I.1.C UI Icons: Status Lights
  drawStatusLights(ctx, ui, panelY) {
    const lightSize = 8 * ui.fontSettings.scale;
    const padding = 5 * ui.fontSettings.scale;
    const startX = padding + 20;
    const lightY = panelY + (ui.height - lightSize) / 2;

    const status = [
      {
        active: ui.game.player.currentSpeed !== 0,
        colorOn: "#00AA00",
        colorOff: "#550000",
        icon: "engine",
      },
      {
        active: !!StopsManager.activeStop,
        colorOn: "#FFAA00",
        colorOff: "#553300",
        icon: "signal",
      },
      {
        active: ui.game.player.headlightsOn,
        colorOn: "#FFFF00",
        colorOff: "#555500",
        icon: "light",
      },
    ];

    status.forEach((s, i) => {
      let lightColor = s.active ? s.colorOn : s.colorOff;
      if (s.active && (s.icon === "signal" || s.icon === "light")) {
        if (Math.floor(ui.game.gameTime * 3) % 2 === 0) {
          lightColor = lightenDarkenColor(lightColor, -40);
        }
      }

      drawPixelRect(
        ctx,
        startX + i * (lightSize + padding),
        lightY,
        lightSize,
        lightSize,
        lightColor
      );
      this.drawSimplePixelBorder(
        ctx,
        startX + i * (lightSize + padding),
        lightY,
        lightSize,
        lightSize,
        lightenDarkenColor(lightColor, -30),
        ui.fontSettings.scale > 1 ? 2 : 1
      );
    });
  },

  // I.1.C UI Icons: Minimap & III.1.C Minimap Enhancements
  drawMiniMap(ctx, ui, panelY) {
    const mapDimension = ui.height - 10 * ui.fontSettings.scale;
    const mapWidth = mapDimension;
    const mapHeight = mapDimension;

    const mapX = Config.CANVAS_WIDTH - mapWidth - 15 * ui.fontSettings.scale;
    const mapY = panelY + (ui.height - mapHeight) / 2;

    this.drawPixelArtFrame(
      ctx,
      mapX - 3,
      mapY - 3,
      mapWidth + 6,
      mapHeight + 6
    );
    drawPixelRect(ctx, mapX, mapY, mapWidth, mapHeight, ui.infoScreenColor);

    const texColor = Palettes.ui.MINIMAP_TEXTURE;
    for (let mx = 0; mx < mapWidth; mx += 4 * ui.fontSettings.scale) {
      for (let my = 0; my < mapHeight; my += 4 * ui.fontSettings.scale) {
        if (
          (mx / (4 * ui.fontSettings.scale) +
            my / (4 * ui.fontSettings.scale)) %
            2 ===
          0
        ) {
          drawPixelRect(
            ctx,
            mapX + mx,
            mapY + my,
            2 * ui.fontSettings.scale,
            2 * ui.fontSettings.scale,
            texColor
          );
        }
      }
    }

    const playerIconSize = 3 * ui.fontSettings.scale;
    const playerMapX = mapX + mapWidth * 0.2 - playerIconSize / 2;
    const playerMapY = mapY + mapHeight / 2 - playerIconSize / 2;

    drawPixelRect(
      ctx,
      playerMapX,
      playerMapY,
      playerIconSize,
      playerIconSize,
      Palettes.ui.MINIMAP_PLAYER
    );
    drawPixelRect(
      ctx,
      playerMapX + playerIconSize,
      playerMapY + playerIconSize / 3,
      playerIconSize / 3,
      playerIconSize / 3,
      Palettes.ui.MINIMAP_PLAYER
    );

    const mapRangeWorldUnits = StopsManager.zoneEntryLeadDistance * 2.5;
    const mapDisplayRangePixels = mapWidth * 0.7;

    StopsManager.stops.forEach((stop, stopIndex) => {
      const distanceToPlayer = stop.worldPositionX - ui.game.world.worldX;
      const normalizedDist = distanceToPlayer / mapRangeWorldUnits;

      if (normalizedDist < 1 && normalizedDist > -0.2) {
        const stopDotSize = 2 * ui.fontSettings.scale;
        const stopDotX = playerMapX + normalizedDist * mapDisplayRangePixels;
        const yOffset =
          (stopIndex - (StopsManager.stops.length - 1) / 2) *
          (stopDotSize * 2.5);
        const stopDotY = mapY + mapHeight / 2 - stopDotSize / 2 + yOffset;

        if (
          stopDotX >= mapX &&
          stopDotX < mapX + mapWidth - stopDotSize &&
          stopDotY >= mapY &&
          stopDotY < mapY + mapHeight - stopDotSize
        ) {
          let stopColor = Palettes.ui.MINIMAP_STOP_DEFAULT;
          if (stop.theme === "gaming")
            stopColor = Palettes.ui.MINIMAP_STOP_GAMING;
          else if (stop.theme === "futuristic")
            stopColor = Palettes.ui.MINIMAP_STOP_FUTURISTIC;
          else if (stop.theme === "industrial")
            stopColor = Palettes.ui.MINIMAP_STOP_INDUSTRIAL;

          if (
            StopsManager.activeStop &&
            StopsManager.activeStop.id === stop.id
          ) {
            const pulse = (Math.sin(ui.game.gameTime * 8) + 1) / 2;
            const pulseSizeIncrease = Math.floor(
              pulse * 2 * ui.fontSettings.scale
            );
            const s = stopDotSize + pulseSizeIncrease;
            drawPixelRect(
              ctx,
              Math.floor(stopDotX - (s - stopDotSize) / 2),
              Math.floor(stopDotY - (s - stopDotSize) / 2),
              s,
              s,
              lightenDarkenColor(stopColor, 30)
            );
          } else {
            drawPixelRect(
              ctx,
              Math.floor(stopDotX),
              Math.floor(stopDotY),
              stopDotSize,
              stopDotSize,
              stopColor
            );
          }
        }
      }
    });

    let nextStopForBoundary = null;
    for (const stop of StopsManager.stops) {
      if (
        stop.worldPositionX - StopsManager.zoneEntryLeadDistance >
        ui.game.world.worldX
      ) {
        nextStopForBoundary = stop;
        break;
      }
    }
    if (nextStopForBoundary) {
      const boundaryWorldX =
        nextStopForBoundary.worldPositionX - StopsManager.zoneEntryLeadDistance;
      const distanceToBoundary = boundaryWorldX - ui.game.world.worldX;
      const normalizedBoundaryDist = distanceToBoundary / mapRangeWorldUnits;

      if (normalizedBoundaryDist < 1 && normalizedBoundaryDist >= 0) {
        const boundaryLineX =
          playerMapX + normalizedBoundaryDist * mapDisplayRangePixels;
        const boundaryLineWidth = 1 * ui.fontSettings.scale;

        if (
          boundaryLineX >= mapX &&
          boundaryLineX < mapX + mapWidth - boundaryLineWidth
        ) {
          ctx.globalAlpha = 0.3;
          drawPixelRect(
            ctx,
            Math.floor(boundaryLineX),
            mapY,
            boundaryLineWidth,
            mapHeight,
            Palettes.ui.FRAME_HIGHLIGHT
          );
          ctx.globalAlpha = 1.0;
        }
      }
    }
  },
};


---
./js/world/generators.js
---
// js/world/generators.js
const WorldGenerators = {
  generateStar(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const sizeArray = options.sizes || [1, 1];
    const size = getRandomInt(sizeArray[0], sizeArray[1]);
    const colorArray = options.colors || ["#FFFFFF"];
    const starColor = getRandomColor(colorArray);
    return {
      type: "star",
      x: x,
      y: y,
      size: size,
      color: starColor,
      initialBrightness: getRandomFloat(0.5, 1.0),
      blinkRate: getRandomFloat(1, 5),
      blinkPhase: getRandomFloat(0, Math.PI * 2),
      originalColor: starColor,
      canRandomizeYOnWrap: true,
      update: function (deltaTime, gameTime) {
        this.blinkFactor =
          (Math.sin(gameTime * this.blinkRate + this.blinkPhase) + 1) / 2;
      },
    };
  },

  generateCelestialBody(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const type = options.type || "sun";
    let radius, color, glowColor;

    switch (type) {
      case "moon":
        radius = getRandomInt(25, 40);
        color = "#E0E0E0";
        glowColor = "#F0F0F0";
        break;
      case "tech_moon":
        radius = getRandomInt(30, 45);
        color = Palettes.futuristic.objects_primary.base;
        glowColor = Palettes.futuristic.emissive[0] + "AA";
        break;
      case "glitch_moon":
        radius = getRandomInt(20, 35);
        color = Palettes.gaming.objects_accent[0];
        glowColor = Palettes.gaming.emissive[1] + "88";
        break;
      case "sun":
      default:
        radius = getRandomInt(30, 50);
        color = Palettes.desert.emissive[0];
        glowColor = lightenDarkenColor(Palettes.desert.emissive[0], 50) + "CC";
        break;
    }
    return {
      type: "celestial_body",
      x: x,
      y: y,
      radius: radius,
      color: color,
      glowColor: glowColor,
      celestialType: type,
      originalColor: color,
      isEmissive: true,
      canRandomizeYOnWrap: false,
    };
  },

  generatePixelCloud(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const sizeRange = options.sizeRange || [20, 50];
    const cloudWidth = getRandomInt(sizeRange[0], sizeRange[1]);
    const cloudHeight = getRandomInt(sizeRange[0] * 0.4, sizeRange[1] * 0.7);
    const yPosRange = options.yPosRange || [0.05, 0.4];
    const cloudColors = options.colors || ["#FFFFFF", "#DDDDFF"];

    return {
      type: "pixelCloud",
      x: x,
      y: getRandomFloat(
        Config.CANVAS_HEIGHT * yPosRange[0],
        world.groundLevelY * yPosRange[1]
      ),
      width: cloudWidth,
      height: cloudHeight,
      colors: cloudColors,
      originalColor: cloudColors[0],
      canRandomizeYOnWrap: true,
    };
  },

  generateNebula(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const nebulaColors = options.colors || [
      Palettes.futuristic.sky[2] + "33",
      Palettes.futuristic.emissive[1] + "22",
    ];
    return {
      type: "nebula",
      x: x,
      y: y,
      width: getRandomInt(200, 400),
      height: getRandomInt(100, 250),
      colors: nebulaColors,
      density: getRandomFloat(0.1, 0.3),
      originalColor: nebulaColors[0],
      isEmissive: true,
      canRandomizeYOnWrap: true,
    };
  },

  generateDesertDistant(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const heightRange = options.heightRange || [50, 100];
    const width = getRandomInt(30, 70);
    const height = getRandomInt(heightRange[0], heightRange[1]);
    const color = options.colorBase || Palettes.desert.objects_primary.shadow;
    return {
      type: "rect_simple_mountain",
      x: x,
      y: world.groundLevelY - height - getRandomInt(10, 40),
      width: width,
      height: height,
      color: color,
      originalColor: color,
      canRandomizeYOnWrap: false,
    };
  },

  generateDesertMid(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const r = Math.random();
    let element;

    if (options.type === "mesa" || (options.type === "mixed" && r < 0.4)) {
      const mesaWidth = getRandomInt(60, 150);
      const mesaHeight = getRandomInt(30, 80);
      element = {
        type: "mesa",
        x: x,
        y: world.groundLevelY - mesaHeight - getRandomInt(0, 20),
        width: mesaWidth,
        height: mesaHeight,
        colors: Palettes.desert.objects_primary,
        originalColor: Palettes.desert.objects_primary.base,
      };
    } else if (options.type === "mixed" && r < 0.8) {
      const cactusHeight = getRandomInt(20, 60);
      element = {
        type: "cactus",
        x: x,
        y: world.groundLevelY - cactusHeight,
        width: getRandomInt(6, 14),
        height: cactusHeight,
        color: Palettes.desert.objects_primary.base,
        originalColor: Palettes.desert.objects_primary.base,
      };
    } else {
      const rockSize = getRandomInt(15, 35);
      element = {
        type: "rock_pile",
        x: x,
        y: world.groundLevelY - rockSize,
        size: rockSize,
        colors: [
          Palettes.desert.objects_primary.base,
          Palettes.desert.objects_primary.shadow,
        ],
        originalColor: Palettes.desert.objects_primary.base,
      };
    }
    element.canRandomizeYOnWrap = false;
    return element;
  },

  generateDesertGround(x, y, layerConfig, game, world) {
    const baseColor = Palettes.desert.ground[0];
    const detailColors = [Palettes.desert.ground[2], Palettes.desert.ground[3]];
    const segmentWidth = Config.CANVAS_WIDTH * 0.5 + getRandomInt(0, 20);
    return {
      type: "textured_ground_rect",
      x: x,
      y: world.groundLevelY,
      width: segmentWidth,
      height: Config.CANVAS_HEIGHT - world.groundLevelY,
      baseColor: baseColor,
      detailColors: detailColors,
      textureType: "desert_cracks_pebbles",
      originalColor: baseColor,
      canRandomizeYOnWrap: false,
    };
  },

  generateForegroundDebris(x, y, layerConfig, game, world) {
    const options = layerConfig.options || { types: ["rock"] };
    const type = getRandomColor(options.types);
    let element = {
      type: "debris",
      x: x,
      y: y,
      size: getRandomInt(3, 8),
      color: "#000000",
      debrisType: type,
      originalColor: "#000000",
      canRandomizeYOnWrap: true,
    };

    switch (type) {
      case "rock":
        element.color = getRandomColor([
          Palettes.desert.ground[2],
          Palettes.desert.ground[3],
        ]);
        break;
      case "tumbleweed_small":
        element.color = Palettes.desert.objects_accent[0];
        element.size = getRandomInt(8, 15);
        break;
      case "glitch_cube":
        element.color = getRandomColor(Palettes.gaming.emissive);
        element.isEmissive = true;
        break;
      case "wire":
        element.color = Palettes.gaming.objects_primary.shadow;
        element.size = getRandomInt(10, 20);
        element.height = getRandomInt(1, 2);
        break;
      case "pixel_coin":
        element.color = Palettes.gaming.emissive[0];
        element.size = getRandomInt(5, 8);
        element.isEmissive = true;
        break;
      case "metal_shard":
        element.color = Palettes.futuristic.objects_primary.base;
        break;
      case "glowing_bit":
        element.color = getRandomColor(Palettes.futuristic.emissive);
        element.isEmissive = true;
        break;
      case "circuit_piece":
        element.color = Palettes.futuristic.objects_accent[1];
        element.size = getRandomInt(6, 12);
        element.height = getRandomInt(2, 4);
        break;
      case "rubble":
        element.color = getRandomColor(Palettes.industrial.ground.slice(1, 3));
        break;
      case "rusty_pipe_fragment":
        element.color = getRandomColor(Palettes.industrial.objects_accent);
        element.size = getRandomInt(10, 18);
        element.height = getRandomInt(3, 5);
        break;
      case "gear":
        element.color = Palettes.industrial.objects_primary.shadow;
        element.size = getRandomInt(7, 10);
        break;
    }
    element.originalColor = element.color;
    return element;
  },

  generateGamingDistant(x, y, layerConfig, game, world) {
    const r = Math.random();
    let element;
    if (r < 0.5) {
      const width = getRandomInt(30, 60);
      const height = getRandomInt(80, Config.CANVAS_HEIGHT * 0.5);
      element = {
        type: "pixelStructure",
        x: x,
        y: world.groundLevelY - height - getRandomInt(10, 30),
        width: width,
        height: height,
        colors: Palettes.gaming.objects_primary,
        density: 0.6,
        originalColor: Palettes.gaming.objects_primary.base,
      };
    } else if (r < 0.8) {
      const width = getRandomInt(50, 100);
      const height = getRandomInt(20, 40);
      element = {
        type: "rect_floating_island",
        x: x,
        y: world.groundLevelY - height - getRandomInt(50, 150),
        width: width,
        height: height,
        colors: {
          top: Palettes.gaming.ground[2],
          bottom: Palettes.gaming.ground[3],
        },
        originalColor: Palettes.gaming.ground[2],
      };
    } else {
      const width = getRandomInt(20, 30);
      const height = getRandomInt(40, 60);
      element = {
        type: "rect",
        x: x,
        y: world.groundLevelY - height - getRandomInt(20, 50),
        width: width,
        height: height,
        color: Palettes.gaming.objects_primary.shadow,
        originalColor: Palettes.gaming.objects_primary.shadow,
      };
    }
    element.canRandomizeYOnWrap = false;
    return element;
  },

  generateGamingMid(x, y, layerConfig, game, world) {
    const r = Math.random();
    let element;
    if (r < 0.4) {
      const trunkHeight = getRandomInt(10, 25);
      const leavesHeight = getRandomInt(20, 40);
      const leavesWidth = getRandomInt(15, 35);
      element = {
        type: "pixelTree",
        x: x,
        y: world.groundLevelY - trunkHeight - leavesHeight,
        trunkWidth: getRandomInt(4, 8),
        trunkHeight: trunkHeight,
        trunkColor: Palettes.desert.objects_accent[0],
        leavesColor: Palettes.gaming.ground[0],
        leavesHighlight: Palettes.gaming.ground[2],
        originalColor: Palettes.gaming.ground[0],
      };
    } else if (r < 0.7) {
      const stemHeight = getRandomInt(15, 30);
      const capRadius = getRandomInt(10, 25);
      element = {
        type: "giant_mushroom",
        x: x,
        y: world.groundLevelY - stemHeight - capRadius,
        stemHeight: stemHeight,
        stemWidth: getRandomInt(5, 10),
        capRadius: capRadius,
        colors: {
          stem: Palettes.gaming.objects_primary.light,
          capTop: getRandomColor(Palettes.gaming.props),
          capSpots: getRandomColor(Palettes.gaming.emissive),
        },
        originalColor: getRandomColor(Palettes.gaming.props),
      };
    } else {
      const size = getRandomInt(10, 20);
      element = {
        type: "power_up_box",
        x: x,
        y: world.groundLevelY - size - getRandomInt(0, 10),
        size: size,
        colors: {
          box: getRandomColor(Palettes.gaming.objects_accent),
          symbol: Palettes.gaming.emissive[0],
        },
        originalColor: getRandomColor(Palettes.gaming.objects_accent),
        isEmissive: true,
      };
    }
    element.canRandomizeYOnWrap = false;
    return element;
  },

  generateGamingGround(x, y, layerConfig, game, world) {
    const segmentWidth = 40;
    const colorIndex = Math.floor(x / segmentWidth) % 2;
    const baseColor = Palettes.gaming.ground[colorIndex];
    const detailColors = [
      Palettes.gaming.ground[2],
      Palettes.gaming.ground[3],
      Palettes.gaming.emissive[2],
    ];
    return {
      type: "textured_ground_rect",
      x: x,
      y: world.groundLevelY,
      width: Config.CANVAS_WIDTH * 0.5 + getRandomInt(0, 10),
      height: Config.CANVAS_HEIGHT - world.groundLevelY,
      baseColor: baseColor,
      detailColors: detailColors,
      textureType: "gaming_grid_flowers",
      originalColor: baseColor,
      canRandomizeYOnWrap: false,
    };
  },

  generateFuturisticSkyElement(x, y, layerConfig, game, world) {
    const r = Math.random();
    if (r < 0.7) {
      const width = getRandomInt(15, 40);
      const height = getRandomInt(5, 10);
      const color = Palettes.futuristic.objects_primary.shadow + "AA";
      return {
        type: "rect",
        x,
        y: getRandomFloat(
          Config.CANVAS_HEIGHT * 0.1,
          Config.CANVAS_HEIGHT * 0.4
        ),
        width,
        height,
        color,
        originalColor: color,
        canRandomizeYOnWrap: true,
      };
    } else {
      const width = getRandomInt(50, 150);
      const height = getRandomInt(1, 3);
      const color = getRandomColor(Palettes.futuristic.emissive) + "66";
      return {
        type: "rect",
        x,
        y: getRandomFloat(
          Config.CANVAS_HEIGHT * 0.1,
          Config.CANVAS_HEIGHT * 0.5
        ),
        width,
        height,
        color,
        originalColor: color,
        isEmissive: true,
        canRandomizeYOnWrap: true,
      };
    }
  },

  generateFuturisticDistant(x, y, layerConfig, game, world) {
    const buildingWidth = getRandomInt(40, 90);
    const buildingHeight = getRandomInt(150, Config.CANVAS_HEIGHT * 0.7);
    return {
      type: "futuristicTower",
      x: x,
      y: world.groundLevelY - buildingHeight,
      width: buildingWidth,
      height: buildingHeight,
      colors: Palettes.futuristic.objects_primary,
      lightColors: Palettes.futuristic.emissive,
      originalColor: Palettes.futuristic.objects_primary.base,
      canRandomizeYOnWrap: false,
    };
  },

  generateFuturisticMid(x, y, layerConfig, game, world) {
    const r = Math.random();
    if (r < 0.6) {
      const platWidth = getRandomInt(50, 120);
      const platHeight = getRandomInt(10, 25);
      return {
        type: "rect_platform",
        x: x,
        y: world.groundLevelY - platHeight - getRandomInt(10, 80),
        width: platWidth,
        height: platHeight,
        colors: {
          base: Palettes.futuristic.objects_primary.base,
          trim: Palettes.futuristic.emissive[0],
        },
        originalColor: Palettes.futuristic.objects_primary.base,
        canRandomizeYOnWrap: false,
      };
    } else {
      const pylonHeight = getRandomInt(30, 70);
      const pylonWidth = getRandomInt(5, 10);
      return {
        type: "energy_pylon",
        x: x,
        y: world.groundLevelY - pylonHeight,
        width: pylonWidth,
        height: pylonHeight,
        colors: {
          structure: Palettes.futuristic.objects_primary.shadow,
          emissive_core: getRandomColor(Palettes.futuristic.emissive),
        },
        originalColor: Palettes.futuristic.objects_primary.shadow,
        isEmissive: true,
        canRandomizeYOnWrap: false,
      };
    }
  },

  generateFuturisticGround(x, y, layerConfig, game, world) {
    const panelWidth = 80;
    const colorIndex = Math.floor(x / panelWidth) % 3;
    const baseColor =
      Palettes.futuristic.ground[
        colorIndex === 0 ? 0 : colorIndex === 1 ? 1 : 0
      ];
    const detailColors = [
      Palettes.futuristic.ground[2],
      Palettes.futuristic.emissive[0],
      Palettes.futuristic.emissive[1],
    ];
    return {
      type: "textured_ground_rect",
      x: x,
      y: world.groundLevelY,
      width: Config.CANVAS_WIDTH * 0.5 + getRandomInt(0, 10),
      height: Config.CANVAS_HEIGHT - world.groundLevelY,
      baseColor: baseColor,
      detailColors: detailColors,
      textureType: "futuristic_guideways",
      originalColor: baseColor,
      canRandomizeYOnWrap: false,
    };
  },

  generateIndustrialDistant(x, y, layerConfig, game, world) {
    const options = layerConfig.options || {};
    const buildingWidth = getRandomInt(70, 150);
    const buildingHeight = getRandomInt(100, Config.CANVAS_HEIGHT * 0.5);
    return {
      type:
        options.type === "smokestack"
          ? "industrialSmokestack"
          : "industrialBuilding",
      x: x,
      y: world.groundLevelY - buildingHeight,
      width: buildingWidth,
      height: buildingHeight,
      colors: Palettes.industrial.objects_primary,
      accentColors: Palettes.industrial.objects_accent,
      smokeColors: Palettes.industrial.smoke,
      originalColor: Palettes.industrial.objects_primary.base,
      canRandomizeYOnWrap: false,
    };
  },

  generateIndustrialMid(x, y, layerConfig, game, world) {
    const r = Math.random();
    let element;
    if (r < 0.4) {
      const size = getRandomInt(15, 30);
      const crateColor = getRandomColor(Palettes.industrial.objects_accent);
      element = {
        type: "rect_crates",
        x,
        y: world.groundLevelY - size,
        width: size,
        height: size,
        color: crateColor,
        originalColor: crateColor,
      };
    } else if (r < 0.7) {
      const length = getRandomInt(40, 100);
      const thickness = getRandomInt(8, 15);
      const pipeColor = Palettes.industrial.objects_primary.shadow;
      element = {
        type: "rect_pipes",
        x,
        y: world.groundLevelY - thickness - getRandomInt(0, 40),
        width: length,
        height: thickness,
        color: pipeColor,
        originalColor: pipeColor,
      };
    } else {
      const pileSize = getRandomInt(20, 40);
      element = {
        type: "rubble_pile",
        x: x,
        y: world.groundLevelY - pileSize * 0.7,
        size: pileSize,
        colors: [
          Palettes.industrial.ground[1],
          Palettes.industrial.objects_primary.shadow,
          Palettes.industrial.objects_accent[0],
        ],
        originalColor: Palettes.industrial.ground[1],
      };
    }
    element.canRandomizeYOnWrap = false;
    return element;
  },

  generateIndustrialGround(x, y, layerConfig, game, world) {
    const r = Math.random();
    let baseColor;
    if (r < 0.6) baseColor = Palettes.industrial.ground[0];
    else if (r < 0.8) baseColor = Palettes.industrial.ground[1];
    else baseColor = Palettes.industrial.objects_accent[1];
    const detailColors = [
      Palettes.industrial.ground[3],
      Palettes.industrial.objects_accent[0],
      Palettes.industrial.emissive[0],
    ];
    return {
      type: "textured_ground_rect",
      x: x,
      y: world.groundLevelY,
      width: Config.CANVAS_WIDTH * 0.5 + getRandomInt(0, 10),
      height: Config.CANVAS_HEIGHT - world.groundLevelY,
      baseColor: baseColor,
      detailColors: detailColors,
      textureType: "industrial_asphalt_cracks",
      originalColor: baseColor,
      canRandomizeYOnWrap: false,
    };
  },
};


---
./js/world/parallax.js
---
// js/world/parallax.js
class ParallaxLayer {
  constructor(
    scrollSpeedFactor,
    elementGenerator,
    elementCount,
    game,
    world,
    layerConfig,
    isSourceLayer = false,
    initialXOffset = 0
  ) {
    this.scrollSpeedFactor = scrollSpeedFactor;
    this.elementGenerator = elementGenerator;
    this.elementCount = elementCount;
    this.game = game;
    this.world = world;
    this.layerConfig = layerConfig;
    this.isSourceLayer = isSourceLayer;
    this.initialXOffset = initialXOffset;
    this.elements = [];
    this.generateInitialElements();
  }

  generateInitialElements() {
    this.elements = [];
    const virtualWidth = Config.CANVAS_WIDTH * 3.5;
    for (let i = 0; i < this.elementCount; i++) {
      const x = this.initialXOffset + Math.random() * virtualWidth;
      let y;
      if (
        this.layerConfig.type &&
        (this.layerConfig.type.includes("sky") ||
          this.layerConfig.type.includes("celestial") ||
          this.layerConfig.type.includes("stars") ||
          this.layerConfig.type.includes("nebulae"))
      ) {
        y = getRandomFloat(
          Config.CANVAS_HEIGHT * 0.05,
          this.world.groundLevelY * 0.55
        );
      } else if (this.layerConfig.type === "foreground_debris") {
        y = getRandomFloat(
          this.world.groundLevelY + 5,
          Config.CANVAS_HEIGHT - 5
        );
      } else if (
        this.layerConfig.type &&
        (this.layerConfig.type.includes("mountain") ||
          this.layerConfig.type.includes("distant"))
      ) {
        y = this.world.groundLevelY;
      } else {
        y = Math.random() * Config.CANVAS_HEIGHT;
      }
      const element = this.elementGenerator(
        x,
        y,
        this.layerConfig,
        this.game,
        this.world
      );
      element.scrollSpeedFactor = this.scrollSpeedFactor; // Tag element with its layer's speed
      this.elements.push(element);
    }
  }

  update(worldScrollSpeed) {
    const layerScrolledOriginX = this.world.worldX * this.scrollSpeedFactor;
    const screenWidth = Config.CANVAS_WIDTH;

    this.elements.forEach((element) => {
      if (element.update) {
        element.update(this.game.deltaTime, this.game.gameTime);
      }
    });

    const wrapBuffer = screenWidth * 0.75;
    const totalVirtualWidth = screenWidth * 3.5;

    if (this.isSourceLayer) {
      this.elements = this.elements.filter((element) => {
        const elementVisualWidth =
          element.width || (element.radius ? element.radius * 2 : 50);
        return (
          element.x + elementVisualWidth > layerScrolledOriginX - wrapBuffer * 2
        );
      });
    } else {
      this.elements.forEach((element) => {
        const elementVisualWidth =
          element.width || (element.radius ? element.radius * 2 : 50);
        const elementScreenX = element.x - layerScrolledOriginX;

        if (elementScreenX + elementVisualWidth < -wrapBuffer) {
          element.x += totalVirtualWidth + Math.random() * 100 - 50;
          if (element.canRandomizeYOnWrap) {
            if (
              this.layerConfig.type &&
              (this.layerConfig.type.includes("sky") ||
                this.layerConfig.type.includes("celestial") ||
                this.layerConfig.type.includes("stars") ||
                this.layerConfig.type.includes("nebulae"))
            ) {
              element.y = getRandomFloat(
                Config.CANVAS_HEIGHT * 0.05,
                this.world.groundLevelY * 0.55
              );
            } else if (this.layerConfig.type === "foreground_debris") {
              element.y = getRandomFloat(
                this.world.groundLevelY + 5,
                Config.CANVAS_HEIGHT - 5
              );
            }
          }
        } else if (elementScreenX > screenWidth + wrapBuffer) {
          element.x -= totalVirtualWidth + Math.random() * 100 - 50;
          if (element.canRandomizeYOnWrap) {
            if (
              this.layerConfig.type &&
              (this.layerConfig.type.includes("sky") ||
                this.layerConfig.type.includes("celestial") ||
                this.layerConfig.type.includes("stars") ||
                this.layerConfig.type.includes("nebulae"))
            ) {
              element.y = getRandomFloat(
                Config.CANVAS_HEIGHT * 0.05,
                this.world.groundLevelY * 0.55
              );
            } else if (this.layerConfig.type === "foreground_debris") {
              element.y = getRandomFloat(
                this.world.groundLevelY + 5,
                Config.CANVAS_HEIGHT - 5
              );
            }
          }
        }
      });
    }
  }

  render(ctx) {
    const renderBuffer = 200;
    const layerScrolledOriginX = this.world.worldX * this.scrollSpeedFactor;

    ctx.save();
    ctx.translate(-layerScrolledOriginX, 0);

    this.elements.forEach((element) => {
      const elementVisualWidth =
        element.width || (element.radius ? element.radius * 2 : 50);

      if (
        element.x + elementVisualWidth > layerScrolledOriginX - renderBuffer &&
        element.x < layerScrolledOriginX + Config.CANVAS_WIDTH + renderBuffer
      ) {
        let elementAlpha = 1.0;
        if (this.world.isTransitioning) {
          if (this.isSourceLayer) {
            elementAlpha = 1.0 - this.world.transitionProgress;
          } else {
            elementAlpha = this.world.transitionProgress;
          }
        }
        elementAlpha = Math.max(0, Math.min(1, elementAlpha));

        if (elementAlpha <= 0.01) return;

        const originalCtxAlpha = ctx.globalAlpha;
        ctx.globalAlpha *= elementAlpha;

        const activeTheme = this.world.isTransitioning
          ? this.isSourceLayer
            ? this.world.transitionSourceTheme
            : this.world.transitionTargetTheme
          : this.world.currentTheme;
        const themePalette = Palettes[activeTheme] || Palettes.desert;

        let finalColor = element.originalColor || element.color;
        if (this.scrollSpeedFactor < 0.8 && !element.isEmissive) {
          const tintFactor = Math.min(0.6, (1 - this.scrollSpeedFactor) * 0.7);
          const skyHorizonColor =
            (themePalette.sky && themePalette.sky[1]) ||
            this.world.currentHorizonSky ||
            "#ABCDEF";

          if (finalColor && typeof finalColor === "string") {
            finalColor = interpolateColor(
              finalColor,
              skyHorizonColor,
              tintFactor
            );
            if (this.scrollSpeedFactor < 0.3) {
              finalColor = desaturateColor(finalColor, tintFactor * 0.5);
            }
          } else if (typeof finalColor !== "string") {
            finalColor = "#FF00FF";
          }
          element.tempColor = finalColor;
        } else {
          element.tempColor = finalColor;
        }

        WorldRenderer.drawElement(ctx, element, this.game.gameTime, this.world);

        ctx.globalAlpha = originalCtxAlpha;
      }
    });
    ctx.restore();
  }
}


---
./js/world/renderer.js
---
// js/world/renderer.js
const WorldRenderer = {
  getSideColor(objectPalette, sideType) {
    if (!objectPalette || typeof objectPalette !== "object") {
      return "#FF00FF";
    }
    switch (sideType) {
      case "light":
        return objectPalette.light || objectPalette.base || "#FFFFFF";
      case "shadow":
        return objectPalette.shadow || objectPalette.base || "#000000";
      case "base":
      default:
        return objectPalette.base || "#808080";
    }
  },

  drawElement(ctx, element, gameTime, world) {
    const drawColor = element.tempColor || element.color || "#FF00FF";
    const scrollSpeedFactor = element.scrollSpeedFactor || 1.0;

    let yOffset = 0;
    const activeThemeForHaze = world.isTransitioning
      ? world.transitionTargetTheme
      : world.currentTheme;
    if (
      activeThemeForHaze === "desert_start" &&
      scrollSpeedFactor < 0.3 &&
      element.y > world.groundLevelY * 0.7
    ) {
      const waveAmplitude = 0.5 + scrollSpeedFactor * 2;
      const waveFrequency = 0.03;
      yOffset =
        Math.sin(element.x * waveFrequency + gameTime * 3) * waveAmplitude;
    }
    const drawY = element.y + yOffset;

    if (element.type === "rect") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        drawColor
      );
    } else if (element.type === "star") {
      const currentAlpha = ctx.globalAlpha;
      const blinkFactor =
        element.blinkFactor !== undefined
          ? element.blinkFactor
          : (Math.sin(gameTime * element.blinkRate + element.blinkPhase) + 1) /
            2;
      ctx.globalAlpha *= element.initialBrightness * blinkFactor;
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.size,
        element.size,
        drawColor
      );
      ctx.globalAlpha = currentAlpha;
    } else if (element.type === "celestial_body") {
      const currentAlpha = ctx.globalAlpha;
      ctx.globalAlpha *= 0.5;
      drawPixelRect(
        ctx,
        element.x - element.radius * 1.2,
        drawY - element.radius * 1.2,
        element.radius * 2.4,
        element.radius * 2.4,
        element.glowColor
      );
      ctx.globalAlpha = currentAlpha;
      drawPixelRect(
        ctx,
        element.x - element.radius,
        drawY - element.radius,
        element.radius * 2,
        element.radius * 2,
        drawColor
      );
      if (element.celestialType === "tech_moon") {
        drawPixelRect(
          ctx,
          element.x - element.radius * 0.8,
          drawY - element.radius * 0.2,
          element.radius * 1.6,
          element.radius * 0.4,
          lightenDarkenColor(drawColor, -30)
        );
        drawPixelRect(
          ctx,
          element.x - element.radius * 0.2,
          drawY - element.radius * 0.8,
          element.radius * 0.4,
          element.radius * 1.6,
          lightenDarkenColor(drawColor, -30)
        );
        if (Math.floor(gameTime * 3) % 2 === 0) {
          drawPixelRect(
            ctx,
            element.x + getRandomFloat(-1, 1) * element.radius * 0.7,
            drawY + getRandomFloat(-1, 1) * element.radius * 0.7,
            2,
            2,
            Palettes.futuristic.emissive[1]
          );
        }
      } else if (
        element.celestialType === "glitch_moon" &&
        Math.floor(gameTime * 10) % 3 === 0
      ) {
        const glitchColor = getRandomColor(Palettes.gaming.emissive);
        drawPixelRect(
          ctx,
          element.x - element.radius + getRandomInt(-5, 5),
          drawY - element.radius + getRandomInt(-5, 5),
          element.radius * 2 + getRandomInt(-2, 2),
          element.radius * 2 + getRandomInt(-2, 2),
          glitchColor
        );
      } else if (element.celestialType === "sun") {
        const numRays = 8;
        for (let i = 0; i < numRays; i++) {
          const angle = (i / numRays) * Math.PI * 2 + gameTime * 0.1;
          const rayLength = element.radius * 1.5;
          const rayStartX = element.x + Math.cos(angle) * element.radius * 0.8;
          const rayStartY = drawY + Math.sin(angle) * element.radius * 0.8;
          const rayEndX = element.x + Math.cos(angle) * rayLength;
          const rayEndY = drawY + Math.sin(angle) * rayLength;
          ctx.globalAlpha =
            currentAlpha * 0.15 * ((Math.sin(gameTime * 2 + i) + 1) / 2);
          ctx.strokeStyle = element.glowColor;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(rayStartX, rayStartY);
          ctx.lineTo(rayEndX, rayEndY);
          ctx.stroke();
        }
        ctx.globalAlpha = currentAlpha;
      }
    } else if (element.type === "pixelCloud") {
      const blockSize = Math.max(2, Math.floor(element.width / 10));
      const numPuffs =
        Math.floor(element.width / blockSize) *
        Math.floor(element.height / blockSize) *
        0.7;
      for (let i = 0; i < numPuffs; i++) {
        const puffX = element.x + Math.random() * (element.width - blockSize);
        const puffY = drawY + Math.random() * (element.height - blockSize);
        const puffColor =
          Math.random() < 0.7 ? element.colors[0] : element.colors[1];
        drawPixelRect(
          ctx,
          puffX,
          puffY,
          blockSize * getRandomFloat(0.8, 1.5),
          blockSize * getRandomFloat(0.8, 1.5),
          puffColor
        );
      }
    } else if (element.type === "nebula") {
      const currentAlpha = ctx.globalAlpha;
      const numParticles = Math.floor(
        (element.width * element.height * element.density) / 25
      );
      for (let i = 0; i < numParticles; i++) {
        const px = element.x + Math.random() * element.width;
        const py = drawY + Math.random() * element.height;
        const psize = getRandomInt(3, 8);
        ctx.globalAlpha = currentAlpha * getRandomFloat(0.3, 0.7);
        drawPixelRect(
          ctx,
          px,
          py,
          psize,
          psize,
          getRandomColor(element.colors)
        );
      }
      ctx.globalAlpha = currentAlpha;
    } else if (element.type === "rect_simple_mountain") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        drawColor
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width * 0.3,
        element.height,
        lightenDarkenColor(drawColor, -15)
      );
      drawPixelRect(
        ctx,
        element.x + element.width * 0.7,
        drawY,
        element.width * 0.3,
        element.height,
        lightenDarkenColor(drawColor, 15)
      );
    } else if (element.type === "mesa") {
      const hThird = element.height / 3;
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        hThird,
        this.getSideColor(element.colors, "light")
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY + hThird,
        element.width,
        hThird,
        this.getSideColor(element.colors, "base")
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY + hThird * 2,
        element.width,
        hThird,
        this.getSideColor(element.colors, "shadow")
      );
      for (let i = 0; i < 5; i++) {
        const lineX = element.x + getRandomInt(5, element.width - 5);
        drawPixelRect(
          ctx,
          lineX,
          drawY + hThird,
          1,
          hThird * 2,
          lightenDarkenColor(this.getSideColor(element.colors, "base"), -20)
        );
      }
    } else if (element.type === "cactus") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        drawColor
      );
      const armWidth = element.width * 0.75;
      const armHeight = element.height * 0.4;
      if (element.height > 25) {
        drawPixelRect(
          ctx,
          element.x - armWidth,
          drawY + element.height * 0.2,
          armWidth,
          armHeight * 0.5,
          drawColor
        );
        drawPixelRect(
          ctx,
          element.x + element.width,
          drawY + element.height * 0.3,
          armWidth,
          armHeight * 0.5,
          drawColor
        );
      }
    } else if (element.type === "rock_pile") {
      const numRocks = getRandomInt(3, 7);
      for (let i = 0; i < numRocks; i++) {
        const rSize = element.size * getRandomFloat(0.3, 0.6);
        const rX = element.x + (Math.random() - 0.5) * element.size * 0.5;
        const rY =
          drawY + element.size - rSize - Math.random() * element.size * 0.3;
        drawPixelRect(
          ctx,
          rX,
          rY,
          rSize,
          rSize,
          getRandomColor(element.colors)
        );
      }
    } else if (element.type === "textured_ground_rect") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        element.baseColor
      );
      const numDetails = Math.floor(
        (element.width * element.height) /
          (element.textureType === "futuristic_guideways" ? 100 : 200)
      );
      for (let i = 0; i < numDetails; i++) {
        const detailX = element.x + Math.random() * element.width;
        const detailY = drawY + Math.random() * element.height * 0.3;
        let dW, dH;
        let detailColor = getRandomColor(element.detailColors);

        if (element.textureType === "desert_cracks_pebbles") {
          dW = Math.random() < 0.5 ? getRandomInt(5, 15) : getRandomInt(1, 3);
          dH = Math.random() < 0.5 ? getRandomInt(1, 3) : getRandomInt(5, 15);
        } else if (element.textureType === "gaming_grid_flowers") {
          dW = getRandomInt(2, 4);
          dH = getRandomInt(2, 4);
          if (Math.random() < 0.1) detailColor = Palettes.gaming.emissive[2];
        } else if (element.textureType === "futuristic_guideways") {
          dW =
            Math.random() < 0.7
              ? element.width * getRandomFloat(0.3, 0.8)
              : getRandomInt(3, 6);
          dH = Math.random() < 0.7 ? getRandomInt(1, 2) : getRandomInt(3, 6);
          if (dH <= 2 && Math.random() < 0.8)
            detailColor = getRandomColor(Palettes.futuristic.emissive);
        } else if (element.textureType === "industrial_asphalt_cracks") {
          dW = Math.random() < 0.5 ? getRandomInt(10, 30) : getRandomInt(2, 5);
          dH = Math.random() < 0.5 ? getRandomInt(1, 3) : getRandomInt(2, 5);
          if (Math.random() < 0.05)
            detailColor = Palettes.industrial.emissive[0];
        } else {
          dW = getRandomInt(2, 8);
          dH = getRandomInt(2, 8);
        }
        drawPixelRect(ctx, detailX, detailY, dW, dH, detailColor);
      }
    } else if (element.type === "debris") {
      if (
        element.debrisType === "wire" ||
        element.debrisType === "rusty_pipe_fragment" ||
        element.debrisType === "circuit_piece"
      ) {
        drawPixelRect(
          ctx,
          element.x,
          drawY,
          element.size,
          element.height,
          drawColor
        );
      } else if (element.debrisType === "gear") {
        const r = element.size / 2;
        drawPixelRect(
          ctx,
          element.x - r,
          drawY - r,
          element.size,
          element.size,
          drawColor
        );
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const toothX = element.x + Math.cos(angle) * r;
          const toothY = drawY + Math.sin(angle) * r;
          drawPixelRect(
            ctx,
            toothX - 1,
            toothY - 1,
            2,
            2,
            lightenDarkenColor(drawColor, -20)
          );
        }
      } else {
        drawPixelRect(
          ctx,
          element.x,
          drawY,
          element.size,
          element.size,
          drawColor
        );
      }
    } else if (element.type === "pixelStructure") {
      const structBlockSize = Math.max(3, Math.floor(element.width / 10));
      const objPalette = element.colors;
      for (let i = 0; i < element.width / structBlockSize; i++) {
        for (let j = 0; j < element.height / structBlockSize; j++) {
          if (
            Math.random() < element.density &&
            element.height - j * structBlockSize >
              Math.random() * element.height * 0.5
          ) {
            let blockColor = this.getSideColor(objPalette, "base");
            if (i < element.width / structBlockSize / 3)
              blockColor = this.getSideColor(objPalette, "shadow");
            else if (i > ((element.width / structBlockSize) * 2) / 3)
              blockColor = this.getSideColor(objPalette, "light");

            const activeThemeForLights = world.isTransitioning
              ? world.transitionTargetTheme
              : world.currentTheme;
            if (
              Math.random() < 0.05 &&
              (activeThemeForLights === "gaming" ||
                activeThemeForLights === "futuristic")
            ) {
              if (Math.floor(gameTime * (3 + Math.random() * 2)) % 2 === 0) {
                blockColor = getRandomColor(
                  Palettes[activeThemeForLights].emissive
                );
              }
            }
            drawPixelRect(
              ctx,
              element.x + i * structBlockSize,
              drawY + j * structBlockSize,
              structBlockSize,
              structBlockSize,
              blockColor
            );
          }
        }
      }
    } else if (element.type === "rect_floating_island") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height * 0.7,
        element.colors.top
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY + element.height * 0.7,
        element.width,
        element.height * 0.3,
        element.colors.bottom
      );
      for (let i = 0; i < 3; i++) {
        drawPixelRect(
          ctx,
          element.x + getRandomInt(0, element.width - 5),
          drawY + getRandomInt(0, element.height * 0.7 - 5),
          5,
          5,
          lightenDarkenColor(element.colors.top, -20)
        );
      }
    } else if (element.type === "pixelTree") {
      drawPixelRect(
        ctx,
        element.x + element.leavesWidth / 2 - element.trunkWidth / 2,
        drawY + element.leavesHeight,
        element.trunkWidth,
        element.trunkHeight,
        element.trunkColor
      );
      const leafBlockSize = Math.max(2, Math.floor(element.leavesWidth / 5));
      for (let r = 0; r < element.leavesHeight / leafBlockSize; r++) {
        for (let c = 0; c < element.leavesWidth / leafBlockSize; c++) {
          if (Math.random() < 0.8) {
            const color =
              Math.random() < 0.7
                ? element.leavesColor
                : element.leavesHighlight;
            drawPixelRect(
              ctx,
              element.x + c * leafBlockSize,
              drawY + r * leafBlockSize,
              leafBlockSize,
              leafBlockSize,
              color
            );
          }
        }
      }
    } else if (element.type === "giant_mushroom") {
      drawPixelRect(
        ctx,
        element.x - element.stemWidth / 2,
        drawY + element.capRadius,
        element.stemWidth,
        element.stemHeight,
        element.colors.stem
      );
      drawPixelRect(
        ctx,
        element.x - element.capRadius,
        drawY,
        element.capRadius * 2,
        element.capRadius,
        element.colors.capTop
      );
      const numSpots = getRandomInt(3, 7);
      for (let i = 0; i < numSpots; i++) {
        const spotSize = element.capRadius * 0.2;
        const spotX =
          element.x -
          element.capRadius +
          Math.random() * (element.capRadius * 2 - spotSize);
        const spotY = drawY + Math.random() * (element.capRadius - spotSize);
        drawPixelRect(
          ctx,
          spotX,
          spotY,
          spotSize,
          spotSize,
          element.colors.capSpots
        );
      }
    } else if (element.type === "power_up_box") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.size,
        element.size,
        element.colors.box
      );
      if (Math.floor(gameTime * 2) % 2 === 0 || !element.isEmissive) {
        drawPixelRect(
          ctx,
          element.x + element.size * 0.3,
          drawY + element.size * 0.2,
          element.size * 0.4,
          element.size * 0.15,
          element.colors.symbol
        );
        drawPixelRect(
          ctx,
          element.x + element.size * 0.55,
          drawY + element.size * 0.35,
          element.size * 0.15,
          element.size * 0.15,
          element.colors.symbol
        );
        drawPixelRect(
          ctx,
          element.x + element.size * 0.4,
          drawY + element.size * 0.5,
          element.size * 0.2,
          element.size * 0.15,
          element.colors.symbol
        );
        drawPixelRect(
          ctx,
          element.x + element.size * 0.4,
          drawY + element.size * 0.8,
          element.size * 0.2,
          element.size * 0.1,
          element.colors.symbol
        );
      }
    } else if (element.type === "futuristicTower") {
      const objPalette = element.colors;
      const baseC = this.getSideColor(objPalette, "base");
      const lightC = this.getSideColor(objPalette, "light");
      const shadowC = this.getSideColor(objPalette, "shadow");

      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        baseC
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width * 0.2,
        element.height,
        shadowC
      );
      drawPixelRect(
        ctx,
        element.x + element.width * 0.8,
        drawY,
        element.width * 0.2,
        element.height,
        lightC
      );

      if (!element.lights) {
        element.lights = [];
        const numLights = Math.floor(element.height / 15);
        for (let i = 0; i < numLights; i++) {
          element.lights.push({
            x_offset: getRandomInt(
              element.width * 0.2,
              element.width * 0.8 - 1
            ),
            y_offset: getRandomInt(
              element.height * 0.1,
              element.height * 0.9 - 1
            ),
            color: getRandomColor(element.lightColors),
            blinkRate: getRandomFloat(1, 4),
            blinkPhase: getRandomFloat(0, Math.PI * 2),
          });
        }
      }
      element.lights.forEach((light) => {
        if (
          Math.floor(gameTime * light.blinkRate + light.blinkPhase) % 2 ===
          0
        ) {
          drawPixelRect(
            ctx,
            element.x + light.x_offset,
            drawY + light.y_offset,
            1,
            1,
            light.color
          );
        }
      });
      drawPixelRect(
        ctx,
        element.x + element.width * 0.4,
        drawY - 10,
        element.width * 0.2,
        10,
        baseC
      );
      drawPixelRect(
        ctx,
        element.x + element.width * 0.45,
        drawY - 15,
        element.width * 0.1,
        5,
        getRandomColor(element.lightColors)
      );
    } else if (element.type === "rect_platform") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        element.colors.base
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY + element.height - 2,
        element.width,
        2,
        element.colors.trim
      );
    } else if (element.type === "energy_pylon") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        element.colors.structure
      );
      const pulse = (Math.sin(gameTime * 5) + 1) / 2;
      const coreHeight = element.height * (0.3 + pulse * 0.2);
      const coreY = drawY + (element.height - coreHeight) / 2;
      drawPixelRect(
        ctx,
        element.x + element.width * 0.25,
        coreY,
        element.width * 0.5,
        coreHeight,
        element.colors.emissive_core
      );
    } else if (
      element.type === "industrialBuilding" ||
      element.type === "industrialSmokestack"
    ) {
      const objPalette = element.colors;
      const baseC = this.getSideColor(objPalette, "base");
      const lightC = this.getSideColor(objPalette, "light");
      const shadowC = this.getSideColor(objPalette, "shadow");

      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        baseC
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width * 0.2,
        element.height,
        shadowC
      );
      drawPixelRect(
        ctx,
        element.x + element.width * 0.8,
        drawY,
        element.width * 0.2,
        element.height,
        lightC
      );

      const numFeatures = Math.floor((element.width * element.height) / 500);
      for (let i = 0; i < numFeatures; i++) {
        const fX =
          element.x +
          getRandomInt(element.width * 0.2, element.width * 0.8 - 5);
        const fY =
          drawY + getRandomInt(element.height * 0.1, element.height * 0.8 - 5);
        const fW = getRandomInt(3, 8);
        const fH = getRandomInt(3, 8);
        drawPixelRect(
          ctx,
          fX,
          fY,
          fW,
          fH,
          Math.random() < 0.2
            ? getRandomColor(Palettes.industrial.emissive)
            : shadowC
        );
      }
      if (element.type === "industrialSmokestack") {
        if (Math.random() < 0.03) {
          world.emitIndustrialSmoke(element.x + element.width / 2, drawY);
        }
      }
    } else if (element.type === "rect_crates") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        drawColor
      );
      drawPixelRect(
        ctx,
        element.x + 1,
        drawY + 1,
        element.width - 2,
        element.height - 2,
        lightenDarkenColor(drawColor, -20)
      );
      drawPixelRect(
        ctx,
        element.x + element.width * 0.4,
        drawY,
        2,
        element.height,
        lightenDarkenColor(drawColor, -30)
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY + element.height * 0.4,
        element.width,
        2,
        lightenDarkenColor(drawColor, -30)
      );
    } else if (element.type === "rect_pipes") {
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height,
        drawColor
      );
      drawPixelRect(
        ctx,
        element.x,
        drawY,
        element.width,
        element.height * 0.3,
        lightenDarkenColor(drawColor, 20)
      );
    } else if (element.type === "rubble_pile") {
      for (let i = 0; i < 5; i++) {
        const rX = element.x + (Math.random() - 0.5) * element.size * 0.8;
        const rY =
          drawY +
          (Math.random() - 0.5) * element.size * 0.3 +
          element.size * 0.2;
        const rSize = element.size * getRandomFloat(0.2, 0.5);
        drawPixelRect(
          ctx,
          rX,
          rY,
          rSize,
          rSize,
          getRandomColor(element.colors)
        );
      }
    }
  },
};


---
./js/world/themes.js
---
// js/world/themes.js
const WorldThemes = {
  desert_start: [
    {
      type: "stars_far",
      speed: 0.01,
      count: 150,
      generator: "generateStar",
      options: { colors: ["#FFFFFF", "#FFFFE0"], sizes: [1, 1] },
    },
    {
      type: "stars_near",
      speed: 0.02,
      count: 70,
      generator: "generateStar",
      options: { colors: ["#FFFFFF", "#F0F8FF"], sizes: [1, 2] },
    },
    {
      type: "celestial",
      speed: 0.03,
      count: 1,
      generator: "generateCelestialBody",
      options: { type: "sun" },
    },
    {
      type: "distant_mountains",
      speed: 0.08,
      count: 10,
      generator: "generateDesertDistant",
      options: {
        colorBase: Palettes.desert.objects_primary.shadow,
        heightRange: [80, 150],
      },
    },
    {
      type: "mid_mesas",
      speed: 0.25,
      count: 15,
      generator: "generateDesertMid",
      options: { type: "mesa" },
    },
    {
      type: "near_rocks_cactus",
      speed: 0.5,
      count: 20,
      generator: "generateDesertMid",
      options: { type: "mixed" },
    },
    {
      type: "ground_texture",
      speed: 1.0,
      count: 8,
      generator: "generateDesertGround",
    },
    {
      type: "foreground_debris",
      speed: 1.5,
      count: 30,
      generator: "generateForegroundDebris",
      options: { types: ["rock", "tumbleweed_small"] },
    },
  ],
  gaming: [
    {
      type: "stars_far",
      speed: 0.02,
      count: 100,
      generator: "generateStar",
      options: { colors: ["#FF00FF", "#00FFFF"], sizes: [1, 1] },
    },
    {
      type: "celestial",
      speed: 0.04,
      count: 1,
      generator: "generateCelestialBody",
      options: { type: "glitch_moon" },
    },
    {
      type: "pixel_clouds",
      speed: 0.1,
      count: 15,
      generator: "generatePixelCloud",
      options: {
        colors: [
          Palettes.gaming.sky[1],
          lightenDarkenColor(Palettes.gaming.sky[1], 20),
        ],
        sizeRange: [30, 80],
      },
    },
    {
      type: "distant_structures",
      speed: 0.25,
      count: 12,
      generator: "generateGamingDistant",
    },
    {
      type: "mid_elements",
      speed: 0.6,
      count: 25,
      generator: "generateGamingMid",
    },
    {
      type: "ground_texture",
      speed: 1.0,
      count: 8,
      generator: "generateGamingGround",
    },
    {
      type: "foreground_debris",
      speed: 1.5,
      count: 25,
      generator: "generateForegroundDebris",
      options: { types: ["glitch_cube", "wire", "pixel_coin"] },
    },
  ],
  futuristic: [
    {
      type: "stars_far",
      speed: 0.01,
      count: 200,
      generator: "generateStar",
      options: { colors: ["#A0A0FF", "#C0C0FF"], sizes: [1, 1] },
    },
    {
      type: "stars_near",
      speed: 0.02,
      count: 100,
      generator: "generateStar",
      options: { colors: ["#FFFFFF", "#E0E0FF"], sizes: [1, 2] },
    },
    {
      type: "nebulae_distant",
      speed: 0.03,
      count: 5,
      generator: "generateNebula",
      options: {
        colors: [
          Palettes.futuristic.sky[2] + "33",
          Palettes.futuristic.emissive[1] + "22",
        ],
      },
    },
    {
      type: "celestial",
      speed: 0.04,
      count: 1,
      generator: "generateCelestialBody",
      options: { type: "tech_moon" },
    },
    {
      type: "sky_traffic",
      speed: 0.15,
      count: 20,
      generator: "generateFuturisticSkyElement",
    },
    {
      type: "distant_towers",
      speed: 0.3,
      count: 15,
      generator: "generateFuturisticDistant",
    },
    {
      type: "mid_platforms",
      speed: 0.55,
      count: 20,
      generator: "generateFuturisticMid",
    },
    {
      type: "ground_guideways",
      speed: 1.0,
      count: 8,
      generator: "generateFuturisticGround",
    },
    {
      type: "foreground_debris",
      speed: 1.5,
      count: 20,
      generator: "generateForegroundDebris",
      options: { types: ["metal_shard", "glowing_bit", "circuit_piece"] },
    },
  ],
  industrial: [
    {
      type: "dense_clouds_low",
      speed: 0.08,
      count: 10,
      generator: "generatePixelCloud",
      options: {
        colors: [Palettes.industrial.smoke[0], Palettes.industrial.sky[2]],
        sizeRange: [80, 150],
        yPosRange: [0.3, 0.6],
      },
    },
    {
      type: "dense_clouds_high",
      speed: 0.12,
      count: 12,
      generator: "generatePixelCloud",
      options: {
        colors: [Palettes.industrial.smoke[1], Palettes.industrial.smoke[2]],
        sizeRange: [60, 120],
        yPosRange: [0.1, 0.4],
      },
    },
    {
      type: "distant_smokestacks",
      speed: 0.25,
      count: 12,
      generator: "generateIndustrialDistant",
      options: { type: "smokestack" },
    },
    {
      type: "mid_buildings_pipes",
      speed: 0.6,
      count: 20,
      generator: "generateIndustrialMid",
    },
    {
      type: "ground_asphalt_cracks",
      speed: 1.0,
      count: 8,
      generator: "generateIndustrialGround",
    },
    {
      type: "foreground_debris",
      speed: 1.5,
      count: 35,
      generator: "generateForegroundDebris",
      options: { types: ["rubble", "rusty_pipe_fragment", "gear"] },
    },
  ],
};


---
./js/world/world.js
---
// js/world/world.js
class World {
  constructor(game) {
    this.game = game;
    this.layers = [];
    this.worldX = 0;
    this.groundLevelY = Config.CANVAS_HEIGHT - 80;

    this.currentTheme = "desert_start";
    const initialPalette = Palettes[this.currentTheme] || Palettes.desert;
    this.skyColor = (initialPalette.sky && initialPalette.sky[0]) || "#FAD7A0";
    this.currentTopSky = this.skyColor;
    this.currentHorizonSky =
      (initialPalette.sky && initialPalette.sky[1]) ||
      lightenDarkenColor(this.currentTopSky, 30);

    this.isTransitioning = false;
    this.transitionProgress = 0;
    this.transitionDurationWorldUnits = Config.CANVAS_WIDTH * 1.1;

    this.transitionSourceSky = this.skyColor;
    this.transitionTargetSky = this.skyColor;
    this.transitionSourceTheme = this.currentTheme;
    this.transitionTargetTheme = this.currentTheme;

    this.sourceLayers = [];
    this.targetLayers = [];

    this.layers = this.initLayers(this.currentTheme, this.worldX);

    if (Config.DEBUG_MODE) console.log("World initialized.");
  }

  initLayers(theme, initialWorldXOffset = 0) {
    const newLayers = [];
    const config = WorldThemes[theme] || WorldThemes["desert_start"];
    config.forEach((lc) => {
      const generatorFunc = WorldGenerators[lc.generator];
      if (generatorFunc) {
        newLayers.push(
          new ParallaxLayer(
            lc.speed,
            generatorFunc,
            lc.count,
            this.game,
            this,
            lc,
            false,
            initialWorldXOffset
          )
        );
      }
    });
    newLayers.sort((a, b) => a.scrollSpeedFactor - b.scrollSpeedFactor);
    return newLayers;
  }

  handleThemeChange(newThemeData) {
    if (this.currentTheme !== newThemeData.theme && !this.isTransitioning) {
      if (Config.DEBUG_MODE) {
        console.log(
          `Starting transition from ${this.currentTheme} to ${newThemeData.theme} at worldX: ${this.worldX}`
        );
      }
      this.isTransitioning = true;
      this.transitionProgress = 0;

      const sourcePalette = Palettes[this.currentTheme] || Palettes.desert;
      this.transitionSourceSky =
        (sourcePalette.sky && sourcePalette.sky[0]) || this.skyColor;

      const targetPalette = Palettes[newThemeData.theme] || Palettes.desert;
      this.transitionTargetSky =
        (targetPalette.sky && targetPalette.sky[0]) || "#87CEEB";

      this.transitionSourceTheme = this.currentTheme;
      this.transitionTargetTheme = newThemeData.theme;

      this.sourceLayers = this.layers;
      this.sourceLayers.forEach((layer) => (layer.isSourceLayer = true));

      const targetLayerInitialX =
        this.worldX +
        (this.game.player.currentSpeed >= 0
          ? Config.CANVAS_WIDTH
          : -Config.CANVAS_WIDTH * 2.5);

      this.targetLayers = this.initLayers(
        this.transitionTargetTheme,
        targetLayerInitialX
      );
      this.targetLayers.forEach((layer) => (layer.isSourceLayer = false));
    } else if (
      !this.isTransitioning &&
      this.currentTheme === newThemeData.theme
    ) {
      const currentPalette = Palettes[this.currentTheme] || Palettes.desert;
      this.skyColor =
        (currentPalette.sky && currentPalette.sky[0]) || this.skyColor;
      this.currentTopSky = this.skyColor;
      this.currentHorizonSky =
        (currentPalette.sky && currentPalette.sky[1]) ||
        lightenDarkenColor(this.currentTopSky, 30);
    }
  }

  emitIndustrialSmoke(x, y) {
    const smokeParticle = new Particle(
      x + getRandomFloat(-5, 5), // World X
      y + getRandomFloat(-5, 0), // World Y
      getRandomFloat(-5, 5),
      getRandomFloat(-10, -20),
      getRandomFloat(1, 3),
      getRandomInt(3, 8),
      getRandomColor(Palettes.industrial.smoke),
      getRandomFloat(0.2, 0.5),
      "weather",
      "weather_background" // Render layer
    );
    smokeParticle.gravity = -5;
    EffectsManager.addParticle(smokeParticle);
  }

  emitWeatherParticles() {
    const theme = this.isTransitioning
      ? this.transitionTargetTheme
      : this.currentTheme;
    const chance = Math.random();
    const paletteForWeather = Palettes[theme] || Palettes.desert;

    const spawnEdgeChoice = Math.random();
    let particleWorldX;
    if (spawnEdgeChoice < 0.45) {
      particleWorldX = this.worldX - 10;
    } else if (spawnEdgeChoice < 0.9) {
      particleWorldX = this.worldX + Config.CANVAS_WIDTH + 10;
    } else {
      particleWorldX = this.worldX + getRandomFloat(0, Config.CANVAS_WIDTH);
    }

    let particleWorldY = -10;

    if (theme === "desert_start" && chance < 0.05) {
      particleWorldY = getRandomFloat(
        this.groundLevelY - 50,
        this.groundLevelY + 20
      );
      const particle = new Particle(
        particleWorldX,
        particleWorldY,
        (particleWorldX < this.worldX + Config.CANVAS_WIDTH / 2 ? 1 : -1) *
          getRandomFloat(20, 50),
        getRandomFloat(-10, 10),
        getRandomFloat(3, 6),
        getRandomInt(2, 5),
        getRandomColor(paletteForWeather.generic_dust || ["#A0522D"]),
        getRandomFloat(0.1, 0.4),
        "weather",
        "weather_foreground"
      );
      particle.drag = 0.99;
      EffectsManager.addParticle(particle);
    } else if (theme === "industrial" && chance < 0.1) {
      const particle = new Particle(
        this.worldX + getRandomFloat(0, Config.CANVAS_WIDTH),
        particleWorldY,
        getRandomFloat(-5, 5),
        getRandomFloat(30, 60),
        getRandomFloat(2, 4),
        getRandomInt(1, 2),
        getRandomColor(
          (paletteForWeather.smoke || ["#A9A9A9"]).map((c) => c + "66")
        ),
        getRandomFloat(0.2, 0.5),
        "weather",
        "weather_foreground"
      );
      EffectsManager.addParticle(particle);
    }
  }

  update(worldScrollSpeed) {
    this.worldX += worldScrollSpeed;

    const currentZoneInfo = StopsManager.getCurrentZone(this.worldX);
    this.handleThemeChange(currentZoneInfo);

    if (this.isTransitioning) {
      this.sourceLayers.forEach((layer) => layer.update(worldScrollSpeed));
      this.targetLayers.forEach((layer) => layer.update(worldScrollSpeed));

      if (this.transitionDurationWorldUnits > 0 && worldScrollSpeed !== 0) {
        const progressIncrement =
          Math.abs(worldScrollSpeed) / this.transitionDurationWorldUnits;
        this.transitionProgress += progressIncrement;
      } else if (
        this.transitionDurationWorldUnits === 0 &&
        worldScrollSpeed !== 0
      ) {
        this.transitionProgress = 1;
      }
      this.transitionProgress = Math.min(this.transitionProgress, 1);

      const sourcePalette =
        Palettes[this.transitionSourceTheme] || Palettes.desert;
      const targetPalette =
        Palettes[this.transitionTargetTheme] || Palettes.desert;
      const sourceTop =
        (sourcePalette.sky && sourcePalette.sky[0]) || this.transitionSourceSky;
      const sourceHorizon =
        (sourcePalette.sky && sourcePalette.sky[1]) ||
        lightenDarkenColor(sourceTop, 30);
      const targetTop =
        (targetPalette.sky && targetPalette.sky[0]) || this.transitionTargetSky;
      const targetHorizon =
        (targetPalette.sky && targetPalette.sky[1]) ||
        lightenDarkenColor(targetTop, 30);
      this.currentTopSky = interpolateColor(
        sourceTop,
        targetTop,
        this.transitionProgress
      );
      this.currentHorizonSky = interpolateColor(
        sourceHorizon,
        targetHorizon,
        this.transitionProgress
      );

      if (this.transitionProgress >= 1) {
        if (Config.DEBUG_MODE)
          console.log(`Transition to ${this.transitionTargetTheme} complete.`);
        this.isTransitioning = false;
        this.currentTheme = this.transitionTargetTheme;

        const finalPalette = Palettes[this.currentTheme] || Palettes.desert;
        this.skyColor =
          (finalPalette.sky && finalPalette.sky[0]) || this.transitionTargetSky;
        this.currentTopSky = this.skyColor;
        this.currentHorizonSky =
          (finalPalette.sky && finalPalette.sky[1]) ||
          lightenDarkenColor(this.currentTopSky, 30);

        this.layers = this.targetLayers;
        this.layers.forEach((layer) => (layer.isSourceLayer = false));
        this.sourceLayers = [];
        this.targetLayers = [];
      }
    } else {
      this.layers.forEach((layer) => layer.update(worldScrollSpeed));
      const currentPalette = Palettes[this.currentTheme] || Palettes.desert;
      this.currentTopSky =
        (currentPalette.sky && currentPalette.sky[0]) || this.skyColor;
      this.currentHorizonSky =
        (currentPalette.sky && currentPalette.sky[1]) ||
        lightenDarkenColor(this.currentTopSky, 30);
    }

    this.emitWeatherParticles();
  }

  render(ctx) {
    const skyGradient = ctx.createLinearGradient(0, 0, 0, this.groundLevelY);
    skyGradient.addColorStop(0, this.currentTopSky);
    skyGradient.addColorStop(1, this.currentHorizonSky);
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, Config.CANVAS_WIDTH, Config.CANVAS_HEIGHT);

    const activeThemeForFog = this.isTransitioning
      ? this.transitionTargetTheme
      : this.currentTheme;
    const themePalette = Palettes[activeThemeForFog] || Palettes.desert;
    if (
      themePalette.atmosphere &&
      themePalette.atmosphere.fogColor &&
      themePalette.atmosphere.fogColor !== "rgba(0,0,0,0.0)"
    ) {
      ctx.fillStyle = themePalette.atmosphere.fogColor;
      ctx.fillRect(0, 0, Config.CANVAS_WIDTH, Config.CANVAS_HEIGHT);
    }

    const layersToRender = this.isTransitioning
      ? [...this.sourceLayers, ...this.targetLayers].sort(
          (a, b) => a.scrollSpeedFactor - b.scrollSpeedFactor
        )
      : this.layers;

    layersToRender.forEach((layer) => {
      if (
        layer.layerConfig.type === "foreground_debris" &&
        layer.scrollSpeedFactor > 1
      )
        return;
      layer.render(ctx);
    });
  }

  renderForeground(ctx) {
    const layersToRender = this.isTransitioning
      ? [...this.sourceLayers, ...this.targetLayers].sort(
          (a, b) => a.scrollSpeedFactor - b.scrollSpeedFactor
        )
      : this.layers;

    layersToRender.forEach((layer) => {
      if (
        layer.layerConfig.type === "foreground_debris" &&
        layer.scrollSpeedFactor > 1
      ) {
        layer.render(ctx);
      }
    });
  }
}


---
./js/stops/stops.manager.js
---
// js/stops/stops.manager.js
const StopsManager = {
  stops: [],
  activeStop: null,
  stopActivationRange: 120,
  zoneEntryLeadDistance: Config.CANVAS_WIDTH * 1.25,

  init() {
    const initialStopPosition = 2500;
    const distanceBetweenStops = 4500;

    this.stops = [
      {
        id: "project_ai_game",
        worldPositionX: initialStopPosition,
        theme: "gaming",
        promptText: "AI Game Project-[F] to Enter",
        markerAssetFunction: "drawArcadeCabinet", // Use string name
        markerScreenYOffset: 0,
        isReached: false,
      },
      {
        id: "project_ai_ta",
        worldPositionX: initialStopPosition + distanceBetweenStops,
        theme: "futuristic",
        promptText: "AI TA Project-[F] to Enter",
        markerAssetFunction: "drawHolographicTerminal", // Use string name
        markerScreenYOffset: 0,
        isReached: false,
      },
      {
        id: "project_truck_parts",
        worldPositionX: initialStopPosition + 2 * distanceBetweenStops,
        theme: "industrial",
        promptText: "Auto Parts Project-[F] to Enter",
        markerAssetFunction: "drawPixelWarehouse", // Use string name
        markerScreenYOffset: 0,
        isReached: false,
      },
    ];
    if (Config.DEBUG_MODE)
      console.log(
        "StopsManager initialized with " + this.stops.length + " stops."
      );
  },

  update(worldCurrentX, playerScreenX, playerWidth, game) {
    this.activeStop = null;
    const playerWorldCenterX = worldCurrentX + playerScreenX + playerWidth / 2;

    for (const stop of this.stops) {
      const distanceToStopMarker = Math.abs(
        playerWorldCenterX - stop.worldPositionX
      );
      if (distanceToStopMarker < this.stopActivationRange / 2) {
        this.activeStop = stop;
        if (Input.isInteractJustPressed()) {
          const linkURL = Config.STOP_LINKS[stop.id];
          if (linkURL) {
            if (Config.DEBUG_MODE) {
              console.log(
                `Interacting with stop: ${stop.promptText}, opening URL: ${linkURL}`
              );
            }
            window.open(linkURL, "_blank");
          }
        }
        break;
      }
    }
  },

  render(ctx, worldCurrentX, playerGroundY, gameTime) {
    this.stops.forEach((stop) => {
      const stopScreenX = stop.worldPositionX - worldCurrentX;
      if (
        stopScreenX > -this.stopActivationRange * 3 &&
        stopScreenX < Config.CANVAS_WIDTH + this.stopActivationRange * 3
      ) {
        const markerY = playerGroundY + stop.markerScreenYOffset;
        const isActiveMarker =
          this.activeStop && this.activeStop.id === stop.id;

        const rendererFunc =
          StopsRenderer[stop.markerAssetFunction] ||
          StopsRenderer.drawDefaultMarker;
        rendererFunc(ctx, stopScreenX, markerY, isActiveMarker, gameTime);

        if (Config.DEBUG_MODE && isActiveMarker) {
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 1;
          const debugRadius = this.stopActivationRange / 2;
          ctx.beginPath();
          ctx.arc(
            Math.floor(stopScreenX),
            Math.floor(markerY - 30),
            Math.floor(debugRadius),
            0,
            Math.PI * 2
          );
          ctx.stroke();
        }
      }
    });
  },

  getCurrentZone(worldCurrentX) {
    let currentZone = {
      name: "The Long Road",
      theme: "desert_start",
      skyColor: (Palettes.desert.sky && Palettes.desert.sky[0]) || "#FAD7A0",
      promptText: "Portfolio Drive",
      stopId: null,
    };

    for (let i = this.stops.length - 1; i >= 0; i--) {
      const stop = this.stops[i];
      const zoneStartPos = stop.worldPositionX - this.zoneEntryLeadDistance;

      if (worldCurrentX >= zoneStartPos) {
        let themePalette = Palettes[stop.theme] || Palettes.desert;
        currentZone = {
          name: `${
            stop.theme.charAt(0).toUpperCase() + stop.theme.slice(1)
          } Sector`,
          theme: stop.theme,
          skyColor: (themePalette.sky && themePalette.sky[0]) || "#87CEEB",
          promptText: stop.promptText,
          stopId: stop.id,
        };
        break;
      }
    }

    if (this.stops.length > 0) {
      const firstStop = this.stops[0];
      const firstZoneStartPos =
        firstStop.worldPositionX - this.zoneEntryLeadDistance;
      if (worldCurrentX < firstZoneStartPos) {
        currentZone = {
          name: "Desert Approach",
          theme: "desert_start",
          skyColor:
            (Palettes.desert.sky && Palettes.desert.sky[0]) || "#FAD7A0",
          promptText: "The Journey Begins...",
          stopId: null,
        };
      }
    }
    return currentZone;
  },
};
StopsManager.init();


---
./js/stops/stops.renderer.js
---
// js/stops/stops.renderer.js
const StopsRenderer = {
  drawDefaultMarker: (ctx, x, y, isActive, gameTime = 0) => {
    const baseColor = isActive ? "yellow" : "orange";
    const detailColor = isActive ? "black" : "#333";

    let pulseFactor = 1.0;
    if (isActive) {
      pulseFactor = 1.0 + ((Math.sin(gameTime * 5) + 1) / 2) * 0.1;
    }

    drawPixelRect(
      ctx,
      x - 15 * pulseFactor,
      y - 60 * pulseFactor,
      30 * pulseFactor,
      60 * pulseFactor,
      baseColor
    );
    drawPixelRect(
      ctx,
      x - 12 * pulseFactor,
      y - 55 * pulseFactor,
      24 * pulseFactor,
      30 * pulseFactor,
      detailColor
    );
    if (isActive) {
      ctx.fillStyle = "yellow";
      ctx.font = "10px Courier New";
      ctx.textAlign = "center";
      ctx.fillText("!", x, y - 40);
      ctx.textAlign = "left";
    }
  },

  drawArcadeCabinet: (ctx, x, y, isActive, gameTime = 0) => {
    const themePalette = Palettes.gaming;
    if (
      !themePalette ||
      !themePalette.objects_primary ||
      !themePalette.emissive ||
      !themePalette.props ||
      !themePalette.objects_accent
    ) {
      StopsRenderer.drawDefaultMarker(ctx, x, y, isActive, gameTime);
      return;
    }

    const cabinetWidth = 32;
    const cabinetHeight = 55;
    const screenHeight = 18;
    const controlPanelHeight = 10;
    const baseHeight = 6;

    let mainColor = themePalette.objects_primary.base;
    let accentColor = themePalette.objects_primary.shadow;
    let screenColor =
      themePalette.emissive && themePalette.emissive.length > 0
        ? themePalette.emissive[0]
        : "#FFFF00";
    let highlightColor = themePalette.objects_primary.light;

    if (isActive) {
      const pulse = (Math.sin(gameTime * 6) + 1) / 2;
      mainColor = interpolateColor(
        themePalette.objects_primary.base,
        themePalette.objects_primary.light,
        pulse * 0.5
      );
      if (themePalette.emissive && themePalette.emissive.length > 0) {
        screenColor = getRandomColor(themePalette.emissive);
      } else {
        screenColor = "#FFFF00";
      }
    }

    drawPixelRect(
      ctx,
      x - cabinetWidth / 2,
      y - baseHeight,
      cabinetWidth,
      baseHeight,
      accentColor
    );
    drawPixelRect(
      ctx,
      x - cabinetWidth / 2,
      y - cabinetHeight,
      cabinetWidth,
      cabinetHeight - baseHeight,
      mainColor
    );
    drawPixelRect(
      ctx,
      x - cabinetWidth / 2,
      y - cabinetHeight,
      3,
      cabinetHeight - baseHeight,
      accentColor
    );
    drawPixelRect(
      ctx,
      x + cabinetWidth / 2 - 3,
      y - cabinetHeight,
      3,
      cabinetHeight - baseHeight,
      highlightColor
    );

    const cpWidth = cabinetWidth + 6;
    const controlPanelColor =
      themePalette.objects_accent && themePalette.objects_accent.length > 0
        ? themePalette.objects_accent[0]
        : "#FF00FF";
    drawPixelRect(
      ctx,
      x - cpWidth / 2,
      y - baseHeight - controlPanelHeight,
      cpWidth,
      controlPanelHeight,
      controlPanelColor
    );
    drawPixelRect(
      ctx,
      x - 5,
      y - baseHeight - controlPanelHeight - 6,
      4,
      6,
      accentColor
    );
    const joystickTopColor =
      themePalette.props && themePalette.props.length > 0
        ? themePalette.props[0]
        : "#FF0000";
    drawPixelRect(
      ctx,
      x - 6,
      y - baseHeight - controlPanelHeight - 9,
      6,
      3,
      joystickTopColor
    );

    const buttonColor1Active =
      themePalette.props && themePalette.props.length > 1
        ? themePalette.props[1]
        : "#FFFF00";
    const buttonColor1Inactive =
      themePalette.props && themePalette.props.length > 2
        ? themePalette.props[2]
        : "#00FF00";
    const buttonColor2Active =
      themePalette.props && themePalette.props.length > 2
        ? themePalette.props[2]
        : "#00FF00";
    const buttonColor2Inactive =
      themePalette.props && themePalette.props.length > 1
        ? themePalette.props[1]
        : "#FFFF00";

    drawPixelRect(
      ctx,
      x + 2,
      y - baseHeight - controlPanelHeight + 3,
      3,
      3,
      isActive ? buttonColor1Active : buttonColor1Inactive
    );
    drawPixelRect(
      ctx,
      x + 7,
      y - baseHeight - controlPanelHeight + 3,
      3,
      3,
      isActive ? buttonColor2Active : buttonColor2Inactive
    );

    drawPixelRect(
      ctx,
      x - cabinetWidth / 2 + 3,
      y - cabinetHeight + 5,
      cabinetWidth - 6,
      screenHeight + 10,
      accentColor
    );
    drawPixelRect(
      ctx,
      x - cabinetWidth / 2 + 5,
      y - cabinetHeight + 7,
      cabinetWidth - 10,
      screenHeight,
      "#000000"
    );

    if (isActive) {
      const numFrames = 3;
      const screenFrame = Math.floor(gameTime * 2) % numFrames;
      const screenPixelSize = 2;
      const screenContentX = x - cabinetWidth / 2 + 6;
      const screenContentY = y - cabinetHeight + 8;
      const activeScreenColor =
        themePalette.emissive && themePalette.emissive.length > 0
          ? screenColor
          : "#FFFF00";
      const playerShipColor =
        themePalette.props && themePalette.props.length > 2
          ? Palettes.gaming.props[2]
          : "#00FF00";

      if (screenFrame === 0) {
        drawPixelRect(
          ctx,
          screenContentX + 4,
          screenContentY + 2,
          screenPixelSize * 2,
          screenPixelSize,
          activeScreenColor
        );
        drawPixelRect(
          ctx,
          screenContentX + 2,
          screenContentY + 4,
          screenPixelSize * 4,
          screenPixelSize,
          activeScreenColor
        );
        drawPixelRect(
          ctx,
          screenContentX,
          screenContentY + 6,
          screenPixelSize * 6,
          screenPixelSize,
          activeScreenColor
        );
        drawPixelRect(
          ctx,
          screenContentX + 2,
          screenContentY + 8,
          screenPixelSize,
          screenPixelSize,
          activeScreenColor
        );
        drawPixelRect(
          ctx,
          screenContentX + 8,
          screenContentY + 8,
          screenPixelSize,
          screenPixelSize,
          activeScreenColor
        );
      } else if (screenFrame === 1) {
        drawPixelRect(
          ctx,
          screenContentX + 6,
          screenContentY + 10,
          screenPixelSize * 2,
          screenPixelSize,
          playerShipColor
        );
        drawPixelRect(
          ctx,
          screenContentX + 4,
          screenContentY + 12,
          screenPixelSize * 4,
          screenPixelSize,
          playerShipColor
        );
      } else {
        const explosionColor =
          themePalette.emissive && themePalette.emissive.length > 0
            ? getRandomColor(Palettes.gaming.emissive)
            : "#FF8C00";
        drawPixelRect(
          ctx,
          screenContentX + 4,
          screenContentY + 5,
          screenPixelSize * 3,
          screenPixelSize * 3,
          explosionColor
        );
      }
    }

    const marqueeHeight = 10;
    const marqueeAccentColor =
      themePalette.objects_accent && themePalette.objects_accent.length > 1
        ? themePalette.objects_accent[1]
        : "#00FF00";
    drawPixelRect(
      ctx,
      x - cabinetWidth / 2 - 2,
      y - cabinetHeight - marqueeHeight,
      cabinetWidth + 4,
      marqueeHeight,
      marqueeAccentColor
    );
    const marqueeTextColorActive =
      themePalette.emissive && themePalette.emissive.length > 2
        ? themePalette.emissive[2]
        : "#FF69B4";
    if (isActive) {
      drawPixelRect(
        ctx,
        x - 5,
        y - cabinetHeight - marqueeHeight + 3,
        10,
        4,
        marqueeTextColorActive
      );
    } else {
      drawPixelRect(
        ctx,
        x - 5,
        y - cabinetHeight - marqueeHeight + 3,
        10,
        4,
        themePalette.objects_primary.shadow
      );
    }

    if (isActive) {
      const glowBaseColor =
        themePalette.emissive && themePalette.emissive.length > 0
          ? themePalette.emissive[0]
          : "#FFFF00";
      ctx.globalAlpha = ((Math.sin(gameTime * 5) + 1) / 2) * 0.3 + 0.1;
      drawPixelRect(
        ctx,
        x - cabinetWidth / 2 - 5,
        y - cabinetHeight - marqueeHeight - 5,
        cabinetWidth + 10,
        cabinetHeight + marqueeHeight + baseHeight + 10,
        glowBaseColor
      );
      ctx.globalAlpha = 1.0;
    }
  },

  drawHolographicTerminal: (ctx, x, y, isActive, gameTime = 0) => {
    const themePalette = Palettes.futuristic;
    if (
      !themePalette ||
      !themePalette.emissive ||
      !themePalette.objects_primary ||
      !themePalette.objects_accent
    ) {
      StopsRenderer.drawDefaultMarker(ctx, x, y, isActive, gameTime);
      return;
    }

    const baseWidth = 40;
    const baseHeight = 10;
    const postHeight = 20;
    const screenWidth = 35;
    const screenHeight = 25;

    let primaryColor =
      themePalette.emissive && themePalette.emissive.length > 0
        ? themePalette.emissive[0]
        : "#00FFFF";
    let accentColor = themePalette.objects_primary.shadow;
    let baseStructColor = themePalette.objects_primary.base;

    if (isActive) {
      const pulse = (Math.sin(gameTime * 4) + 1) / 2;
      if (themePalette.emissive && themePalette.emissive.length > 1) {
        primaryColor = interpolateColor(
          themePalette.emissive[0],
          themePalette.emissive[1],
          pulse
        );
      } else if (themePalette.emissive && themePalette.emissive.length > 0) {
        primaryColor = themePalette.emissive[0];
      } else {
        primaryColor = "#00FFFF";
      }
      baseStructColor = lightenDarkenColor(
        themePalette.objects_primary.base,
        Math.floor(pulse * 20)
      );
    }

    drawPixelRect(
      ctx,
      x - baseWidth / 2,
      y - baseHeight,
      baseWidth,
      baseHeight,
      baseStructColor
    );
    drawPixelRect(
      ctx,
      x - baseWidth / 2 + 2,
      y - baseHeight + 2,
      baseWidth - 4,
      baseHeight - 4,
      accentColor
    );
    drawPixelRect(
      ctx,
      x - 4,
      y - baseHeight - postHeight,
      8,
      postHeight,
      baseStructColor
    );

    const screenY = y - baseHeight - postHeight - screenHeight;

    const numLayers = isActive ? 4 : 2;
    for (let i = 0; i < numLayers; i++) {
      const layerAlpha = isActive ? 0.2 + i * 0.15 : 0.3 + i * 0.1;
      const layerOffset = isActive ? Math.sin(gameTime * 2 + i) * 3 : 0;
      const layerWidth = screenWidth + i * 4;
      const layerHeight = screenHeight + i * 2;

      ctx.globalAlpha = layerAlpha;
      drawPixelRect(
        ctx,
        x - layerWidth / 2,
        screenY - i * 2 + layerOffset,
        layerWidth,
        layerHeight,
        primaryColor
      );
      ctx.globalAlpha = 1.0;
    }

    const strokeStyleColor =
      themePalette.objects_accent && themePalette.objects_accent.length > 0
        ? themePalette.objects_accent[0]
        : themePalette.objects_primary.light;
    ctx.strokeStyle = isActive
      ? strokeStyleColor
      : themePalette.objects_primary.light;
    ctx.lineWidth = 1;
    const lineCount = 5;
    for (let i = 0; i < lineCount; i++) {
      const lineYVal = screenY + 4 + i * (screenHeight / lineCount);
      const scrollOffset = isActive ? (gameTime * 15 + i * 5) % screenWidth : 0;
      ctx.beginPath();
      ctx.moveTo(
        Math.floor(x - screenWidth / 2 + 3 + scrollOffset),
        Math.floor(lineYVal)
      );
      ctx.lineTo(
        Math.floor(x - screenWidth / 2 + 3 + scrollOffset - 10),
        Math.floor(lineYVal)
      );
      ctx.stroke();

      if (isActive && Math.random() < 0.3) {
        const glyphColor =
          themePalette.emissive && themePalette.emissive.length > 2
            ? themePalette.emissive[2]
            : "#FFFF00";
        drawPixelRect(
          ctx,
          x - screenWidth / 2 + getRandomInt(5, screenWidth - 10),
          lineYVal - 2,
          2,
          2,
          glyphColor
        );
      }
    }

    if (isActive) {
      ctx.globalAlpha = ((Math.sin(gameTime * 5) + 1) / 2) * 0.2 + 0.1;
      drawPixelRect(
        ctx,
        x - screenWidth / 2 - 10,
        screenY - 10,
        screenWidth + 20,
        screenHeight + 20,
        primaryColor
      );
      ctx.globalAlpha = 1.0;
    }
  },

  drawPixelWarehouse: (ctx, x, y, isActive, gameTime = 0) => {
    const themePalette = Palettes.industrial;
    if (
      !themePalette ||
      !themePalette.objects_primary ||
      !themePalette.objects_accent ||
      !themePalette.emissive
    ) {
      StopsRenderer.drawDefaultMarker(ctx, x, y, isActive, gameTime);
      return;
    }

    const buildingWidth = 55;
    const buildingHeight = 45;
    const roofHeight = 12;
    const doorWidth = 18;
    const doorHeight = 28;

    let mainColor = themePalette.objects_primary.base;
    let roofColor = themePalette.objects_primary.shadow;
    let doorColor =
      themePalette.objects_accent && themePalette.objects_accent.length > 1
        ? themePalette.objects_accent[1]
        : "#A0522D";
    let highlightColor = themePalette.objects_primary.light;

    if (isActive) {
      const pulse = (Math.sin(gameTime * 3) + 1) / 2;
      mainColor = lightenDarkenColor(
        themePalette.objects_primary.base,
        Math.floor(pulse * 10)
      );
      if (
        themePalette.objects_accent &&
        themePalette.objects_accent.length > 1 &&
        themePalette.emissive &&
        themePalette.emissive.length > 0
      ) {
        doorColor = interpolateColor(
          themePalette.objects_accent[1],
          themePalette.emissive[0],
          pulse
        );
      } else {
        doorColor = "#FFA500";
      }
    }

    drawPixelRect(
      ctx,
      x - buildingWidth / 2,
      y - buildingHeight,
      buildingWidth / 3,
      buildingHeight,
      themePalette.objects_primary.shadow
    );
    drawPixelRect(
      ctx,
      x - buildingWidth / 2 + buildingWidth / 3,
      y - buildingHeight,
      buildingWidth / 3,
      buildingHeight,
      mainColor
    );
    drawPixelRect(
      ctx,
      x - buildingWidth / 2 + (buildingWidth * 2) / 3,
      y - buildingHeight,
      buildingWidth / 3,
      buildingHeight,
      highlightColor
    );

    for (let i = 0; i < buildingHeight; i += 4) {
      drawPixelRect(
        ctx,
        x - buildingWidth / 2,
        y - buildingHeight + i,
        buildingWidth,
        1,
        lightenDarkenColor(mainColor, -20)
      );
    }

    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(
      Math.floor(x - buildingWidth / 2 - 3),
      Math.floor(y - buildingHeight)
    );
    ctx.lineTo(
      Math.floor(x + buildingWidth / 2 + 3),
      Math.floor(y - buildingHeight)
    );
    ctx.lineTo(
      Math.floor(x + buildingWidth / 2),
      Math.floor(y - buildingHeight - roofHeight)
    );
    ctx.lineTo(
      Math.floor(x - buildingWidth / 2),
      Math.floor(y - buildingHeight - roofHeight)
    );
    ctx.closePath();
    ctx.fill();
    drawPixelRect(
      ctx,
      x - buildingWidth / 2,
      y - buildingHeight - roofHeight,
      buildingWidth,
      2,
      lightenDarkenColor(roofColor, 20)
    );

    const doorX = x - doorWidth / 2;
    const doorY = y - doorHeight;
    drawPixelRect(ctx, doorX, doorY, doorWidth, doorHeight, doorColor);
    for (let i = 0; i < doorHeight; i += 6) {
      drawPixelRect(
        ctx,
        doorX,
        doorY + i,
        doorWidth,
        2,
        lightenDarkenColor(doorColor, -30)
      );
    }
    drawPixelRect(
      ctx,
      doorX + doorWidth / 2 - 2,
      doorY + doorHeight * 0.7,
      4,
      2,
      lightenDarkenColor(doorColor, -50)
    );

    if (isActive) {
      const lightOn = Math.floor(gameTime * 2) % 2 === 0;
      const activeLightColor =
        themePalette.emissive && themePalette.emissive.length > 0
          ? themePalette.emissive[0]
          : "#FFA500";
      if (lightOn) {
        drawPixelRect(
          ctx,
          x - 2,
          y - buildingHeight - roofHeight - 5,
          4,
          3,
          activeLightColor
        );
        ctx.globalAlpha = 0.3;
        drawPixelRect(
          ctx,
          x - 4,
          y - buildingHeight - roofHeight - 2,
          8,
          5,
          activeLightColor
        );
        ctx.globalAlpha = 1.0;
      } else {
        drawPixelRect(
          ctx,
          x - 2,
          y - buildingHeight - roofHeight - 5,
          4,
          3,
          themePalette.objects_primary.shadow
        );
      }
    }

    const signAccentColor =
      themePalette.objects_accent && themePalette.objects_accent.length > 0
        ? themePalette.objects_accent[0]
        : "#B7410E";
    const signEmissiveColor =
      themePalette.emissive && themePalette.emissive.length > 1
        ? themePalette.emissive[1]
        : "#FFD700";
    drawPixelRect(
      ctx,
      x + buildingWidth / 2 - 15,
      y - buildingHeight + 5,
      10,
      8,
      themePalette.objects_primary.shadow
    );
    drawPixelRect(
      ctx,
      x + buildingWidth / 2 - 14,
      y - buildingHeight + 6,
      8,
      6,
      isActive ? signEmissiveColor : signAccentColor
    );

    if (isActive) {
      const glowColorActive =
        themePalette.emissive && themePalette.emissive.length > 1
          ? themePalette.emissive[1]
          : "#FFD700";
      ctx.globalAlpha = ((Math.sin(gameTime * 5) + 1) / 2) * 0.15;
      drawPixelRect(
        ctx,
        x - buildingWidth / 2 - 5,
        y - buildingHeight - roofHeight - 5,
        buildingWidth + 10,
        buildingHeight + roofHeight + 10,
        glowColorActive
      );
      ctx.globalAlpha = 1.0;
    }
  },
};


---
./js/effects/effects.manager.js
---
// js/effects/effects.manager.js

const EffectsManager = {
  particles: [],

  addParticle(particle) {
    this.particles.push(particle);
  },

  update(deltaTime) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].update(deltaTime);
      if (this.particles[i].lifespan <= 0 || this.particles[i].alpha <= 0) {
        this.particles.splice(i, 1);
      }
    }
  },

  renderLayer(ctx, layer) {
    this.particles.forEach((particle) => {
      if (particle.layer === layer) {
        // For weather particles that are in world-space, we need to translate the context
        const isWorldSpace =
          layer === "weather_background" || layer === "weather_foreground";
        if (isWorldSpace) {
          ctx.save();
          // This assumes `game.world.worldX` is accessible. A better approach would be passing worldX.
          // For now, we rely on the Game loop to handle this translation before calling.
          // Let's assume the context is already translated for world-space particles.
        }

        particle.render(ctx);

        if (isWorldSpace) {
          ctx.restore();
        }
      }
    });
  },

  // --- Screen Effects ---
  drawVignette(ctx) {
    const midX = Config.CANVAS_WIDTH / 2;
    const midY = Config.CANVAS_HEIGHT / 2;
    const outerRadius = Config.CANVAS_WIDTH * 0.7;
    const innerRadius = Config.CANVAS_WIDTH * 0.35; // Adjusted for a more noticeable effect

    const vignetteGradient = ctx.createRadialGradient(
      midX,
      midY,
      innerRadius,
      midX,
      midY,
      outerRadius
    );
    vignetteGradient.addColorStop(0, "rgba(0,0,0,0)");
    vignetteGradient.addColorStop(1, "rgba(0,0,0,0.3)"); // Slightly darker
    ctx.fillStyle = vignetteGradient;
    ctx.fillRect(0, 0, Config.CANVAS_WIDTH, Config.CANVAS_HEIGHT);
  },

  drawScanlines(ctx, world) {
    // Example: only for gaming or futuristic themes
    if (
      world &&
      (world.currentTheme === "gaming" ||
        world.currentTheme === "futuristic" ||
        (world.isTransitioning &&
          (world.transitionTargetTheme === "gaming" ||
            world.transitionTargetTheme === "futuristic")))
    ) {
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      for (let y = 0; y < Config.CANVAS_HEIGHT; y += 3) {
        ctx.fillRect(0, y, Config.CANVAS_WIDTH, 1);
      }
    }
  },
};


---
./js/effects/particle.js
---
// js/effects/particle.js

class Particle {
  constructor(
    x,
    y,
    vx,
    vy,
    lifespan,
    size,
    color,
    alpha = 1.0,
    type = "generic",
    layer = "foreground" // e.g., 'behind_player', 'foreground', 'weather_background'
  ) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.lifespan = lifespan; // in seconds
    this.initialLifespan = lifespan;
    this.size = size;
    this.color = color;
    this.alpha = alpha;
    this.initialAlpha = alpha;
    this.type = type; // e.g., "dust", "exhaust", "speedline", "weather"
    this.layer = layer;
    this.gravity = 0; // Specific to particle type
    this.drag = 1.0; // Multiplicative drag
  }

  update(deltaTime) {
    this.vy += this.gravity * deltaTime;
    this.vx *= this.drag;
    this.vy *= this.drag; // Apply drag to vy as well if needed

    this.x += this.vx * deltaTime;
    this.y += this.vy * deltaTime;
    this.lifespan -= deltaTime;

    // Fade out based on lifespan
    if (this.initialLifespan > 0) {
      this.alpha = this.initialAlpha * (this.lifespan / this.initialLifespan);
    }
    this.alpha = Math.max(0, this.alpha);
  }

  render(ctx) {
    if (this.lifespan <= 0 || this.alpha <= 0) return;

    ctx.globalAlpha = this.alpha;
    if (this.type === "speedline") {
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.size;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * 0.1, this.y - this.vy * 0.1); // Length based on velocity
      ctx.stroke();
    } else {
      drawPixelRect(
        ctx,
        this.x - this.size / 2,
        this.y - this.size / 2,
        this.size,
        this.size,
        this.color
      );
    }
    ctx.globalAlpha = 1.0;
  }
}


---
./js/player/player.js
---
// js/player/player.js
class Player {
  constructor(game) {
    this.game = game;
    this.width = 72;
    this.height = 36;
    this.screenX = (Config.CANVAS_WIDTH - this.width) / 2;
    this.screenY = Config.CANVAS_HEIGHT - this.height - 70;

    this.bobAngle = 0;
    this.bobSpeed = 0.15;
    this.bobAmplitude = 1.5;

    this.wheelFrame = 0;
    this.wheelAnimationSpeed = 0.25;
    this.wheelRadius = 7;

    this.currentSpeed = 0;
    this.maxSpeed = 8;
    this.acceleration = 0.12;
    this.deceleration = 0.06;
    this.brakingDeceleration = 0.2;

    this.effectiveY = this.screenY;

    this.tiltAngle = 0;
    this.maxTilt = 0.05;
    this.tiltSpeed = 0.1;

    this.headlightsOn = false;
    this.isBraking = false;

    if (Config.DEBUG_MODE) console.log("Player initialized.");
  }

  update(deltaTime) {
    let movingIntent = 0; // -1 for left, 1 for right, 0 for no input
    if (Input.isMoveRightPressed()) {
      movingIntent = 1;
    }
    if (Input.isMoveLeftPressed()) {
      movingIntent = -1;
    }

    this.isBraking = false;
    if (movingIntent !== 0) {
      this.currentSpeed += this.acceleration * movingIntent;
      this.currentSpeed = Math.max(
        -this.maxSpeed,
        Math.min(this.maxSpeed, this.currentSpeed)
      );
    } else {
      // Decelerate or brake
      if (this.currentSpeed > 0) {
        if (Input.isMoveLeftPressed()) {
          this.currentSpeed -= this.brakingDeceleration;
          this.isBraking = true;
        } else {
          this.currentSpeed -= this.deceleration;
        }
        if (this.currentSpeed < 0) this.currentSpeed = 0;
      } else if (this.currentSpeed < 0) {
        if (Input.isMoveRightPressed()) {
          this.currentSpeed += this.brakingDeceleration;
          this.isBraking = true;
        } else {
          this.currentSpeed += this.deceleration;
        }
        if (this.currentSpeed > 0) this.currentSpeed = 0;
      }
    }

    // Tilt logic
    let targetTilt = 0;
    if (this.currentSpeed > 0.1 && movingIntent === 1)
      targetTilt = -this.maxTilt;
    else if (this.currentSpeed < -0.1 && movingIntent === -1)
      targetTilt = -this.maxTilt;
    else if (this.isBraking)
      targetTilt = this.maxTilt * Math.sign(this.currentSpeed) * 1.5;

    this.tiltAngle +=
      (targetTilt - this.tiltAngle) * this.tiltSpeed * (60 * deltaTime);

    // Bobbing
    this.bobAngle +=
      this.bobSpeed *
      (Math.abs(this.currentSpeed) / this.maxSpeed + 0.1) *
      (60 * deltaTime);
    const bobOffset =
      Math.sin(this.bobAngle) *
      this.bobAmplitude *
      (Math.abs(this.currentSpeed) > 0.1 ? 1 : 0.5);
    this.effectiveY = this.screenY + bobOffset;

    // Wheel animation
    if (Math.abs(this.currentSpeed) > 0.1) {
      this.wheelFrame +=
        this.wheelAnimationSpeed *
        Math.sign(this.currentSpeed) *
        (60 * deltaTime);
      if (this.wheelFrame >= 8) this.wheelFrame = 0;
      if (this.wheelFrame < 0) this.wheelFrame = 7;
    }

    // Headlight toggle
    if (Input.isToggleHeadlightsJustPressed()) {
      this.headlightsOn = !this.headlightsOn;
    }

    // Particle Emission
    this.emitDustParticles();
    this.emitExhaustParticles();
    this.emitSpeedLines();
  }

  emitDustParticles() {
    if (Math.abs(this.currentSpeed) > Config.PLAYER_DUST_EMIT_THRESHOLD) {
      const wheelY = this.screenY + this.height - this.wheelRadius / 2;
      let particlesToEmit = Math.floor(
        Math.abs(this.currentSpeed / this.maxSpeed) *
          Config.MAX_DUST_PARTICLES_PER_FRAME
      );

      for (let i = 0; i < particlesToEmit; i++) {
        const wheelX =
          this.currentSpeed > 0
            ? this.screenX + this.width * 0.15 + this.wheelRadius
            : this.screenX + this.width * 0.75 + this.wheelRadius;

        const particle = new Particle(
          wheelX + getRandomFloat(-this.wheelRadius, this.wheelRadius),
          wheelY + getRandomFloat(0, this.wheelRadius / 2),
          -this.currentSpeed * getRandomFloat(0.1, 0.3),
          getRandomFloat(-10, -30),
          getRandomFloat(0.5, 1.2),
          getRandomInt(1, 3),
          getRandomColor(Palettes.vehicle.DUST_COLOR),
          getRandomFloat(0.3, 0.6),
          "dust",
          "behind_player"
        );
        particle.gravity = 20;
        EffectsManager.addParticle(particle);
      }
    }
  }

  emitExhaustParticles() {
    const isAccelerating =
      Math.abs(this.currentSpeed) > Config.PLAYER_EXHAUST_EMIT_THRESHOLD &&
      ((this.currentSpeed > 0 && Input.isMoveRightPressed()) ||
        (this.currentSpeed < 0 && Input.isMoveLeftPressed()));

    if (isAccelerating) {
      let particlesToEmit = Config.MAX_EXHAUST_PARTICLES_PER_FRAME;
      for (let i = 0; i < particlesToEmit; i++) {
        const exhaustOffsetX =
          this.currentSpeed >= 0 ? this.width * 0.05 : this.width * 0.95;
        const particle = new Particle(
          this.screenX + exhaustOffsetX,
          this.effectiveY + this.height * 0.6,
          this.currentSpeed * 0.3 + getRandomFloat(-5, 5),
          getRandomFloat(-15, -5),
          getRandomFloat(0.3, 0.8),
          getRandomInt(1, 3),
          getRandomColor(Palettes.vehicle.EXHAUST_SMOKE),
          getRandomFloat(0.2, 0.5),
          "exhaust",
          "behind_player"
        );
        particle.gravity = -5;
        particle.drag = 0.98;
        EffectsManager.addParticle(particle);
      }
    }
  }

  emitSpeedLines() {
    if (Math.abs(this.currentSpeed) > Config.PLAYER_SPEED_LINE_THRESHOLD) {
      let linesToEmit = Math.floor(
        Math.abs(this.currentSpeed / this.maxSpeed) *
          Config.MAX_SPEED_LINES_PER_FRAME
      );
      for (let i = 0; i < linesToEmit; i++) {
        const side = Math.random() < 0.5 ? -1 : 1;
        const particle = new Particle(
          this.screenX +
            this.width / 2 +
            side * Config.CANVAS_WIDTH * getRandomFloat(0.3, 0.6),
          this.screenY +
            this.height / 2 +
            getRandomFloat(-this.height * 0.5, this.height * 0.5),
          -this.currentSpeed * getRandomFloat(1.5, 2.5),
          0,
          getRandomFloat(0.1, 0.3),
          getRandomInt(1, 2),
          `rgba(200,200,220,${getRandomFloat(0.3, 0.7)})`,
          1.0,
          "speedline",
          "behind_player"
        );
        EffectsManager.addParticle(particle);
      }
    }
  }

  render(ctx) {
    // All rendering is now delegated to the PlayerRenderer
    PlayerRenderer.render(ctx, this);
  }
}


---
./js/player/player.renderer.js
---
// js/player/player.renderer.js
const PlayerRenderer = {
  // I.1.A Player Vehicle: Refined Pixel Art Assets
  // I.1.C Wheel Rotation (More Frames)
  drawWheel(ctx, x, y, radius, frame) {
    const wheelColors = Palettes.vehicle;
    // Simplified 8-frame rotation (4 unique designs, mirrored or slightly shifted for 8)
    const currentFrame = Math.floor(frame) % 8;

    // Tire
    drawPixelRect(
      ctx,
      x - radius,
      y - radius,
      radius * 2,
      radius * 2,
      wheelColors.CAR_TIRE_DARK
    );
    drawPixelRect(
      ctx,
      x - radius + 1,
      y - radius + 1,
      radius * 2 - 2,
      radius * 2 - 2,
      wheelColors.CAR_TIRE_LIGHT
    );

    // Hubcap
    const hubRadius = radius * 0.6;
    drawPixelRect(
      ctx,
      x - hubRadius,
      y - hubRadius,
      hubRadius * 2,
      hubRadius * 2,
      wheelColors.CAR_BODY_ACCENT
    );
    drawPixelRect(
      ctx,
      x - hubRadius + 1,
      y - hubRadius + 1,
      hubRadius * 2 - 2,
      hubRadius * 2 - 2,
      lightenDarkenColor(wheelColors.CAR_BODY_ACCENT, 20)
    );

    // Spokes (example for 8 frames)
    ctx.strokeStyle = wheelColors.CAR_TIRE_DARK;
    ctx.lineWidth = Math.max(1, Math.floor(radius / 4));

    const angleOffset = (Math.PI / 4) * currentFrame; // For 8 spokes/positions
    for (let i = 0; i < 2; i++) {
      // Two main spokes, 90 deg apart
      const angle = angleOffset + (i * Math.PI) / 2;
      const startX = x + Math.cos(angle) * hubRadius * 0.5;
      const startY = y + Math.sin(angle) * hubRadius * 0.5;
      const endX = x + Math.cos(angle) * radius * 0.9;
      const endY = y + Math.sin(angle) * radius * 0.9;
      ctx.beginPath();
      ctx.moveTo(Math.floor(startX), Math.floor(startY));
      ctx.lineTo(Math.floor(endX), Math.floor(endY));
      ctx.stroke();
    }
  },

  render(ctx, player) {
    const carX = player.screenX;
    // I.1.C Suspension Bobbing: Body uses effectiveY, wheels use a non-bobbing Y.
    const bodyY = player.effectiveY;
    const wheelBaseY = player.screenY + player.height - player.wheelRadius; // Non-bobbing Y for wheels

    const carColors = Palettes.vehicle;

    // Apply tilt - this is a simplified approach.
    const frontTiltOffset = Math.sin(player.tiltAngle) * (player.width / 2);
    const rearTiltOffset = -Math.sin(player.tiltAngle) * (player.width / 2);

    // Player Shadow (I.2.B)
    drawPixelRect(
      ctx,
      carX + 5,
      wheelBaseY + player.wheelRadius - 3, // Positioned under the wheels
      player.width - 10,
      6, // Shadow height
      "rgba(0, 0, 0, 0.2)"
    );

    // Wheels (drawn first, at non-bobbing Y)
    const frontWheelX = carX + player.width * 0.2;
    const rearWheelX = carX + player.width * 0.8 - player.wheelRadius * 2;

    this.drawWheel(
      ctx,
      frontWheelX + player.wheelRadius,
      wheelBaseY,
      player.wheelRadius,
      player.wheelFrame
    );
    this.drawWheel(
      ctx,
      rearWheelX + player.wheelRadius,
      wheelBaseY,
      player.wheelRadius,
      player.wheelFrame
    );

    // Car Body - More detailed pixel art car (I.1.A)
    const mainBodyHeight = player.height * 0.65;
    drawPixelRect(
      ctx,
      carX,
      bodyY + player.height * 0.1 + rearTiltOffset / 2,
      player.width,
      mainBodyHeight,
      carColors.CAR_BODY_MAIN
    );
    // Highlight on body
    drawPixelRect(
      ctx,
      carX + player.width * 0.1,
      bodyY + player.height * 0.15 + rearTiltOffset / 2,
      player.width * 0.8,
      mainBodyHeight * 0.2,
      lightenDarkenColor(carColors.CAR_BODY_MAIN, 20)
    );

    // 3. Cabin/Windows
    const cabinHeight = player.height * 0.5;
    const cabinWidth = player.width * 0.6;
    const cabinX = carX + player.width * 0.2;
    const cabinY = bodyY - cabinHeight * 0.4 + frontTiltOffset / 2;

    drawPixelRect(
      ctx,
      cabinX,
      cabinY,
      cabinWidth,
      cabinHeight,
      carColors.CAR_ROOF
    ); // Cabin structure first

    // Windows (inset within cabin structure)
    const windowInset = 4;
    const windowHeight = cabinHeight - windowInset * 1.5;
    // Windshield (slanted)
    ctx.fillStyle = carColors.CAR_WINDOW;
    ctx.beginPath();
    ctx.moveTo(cabinX + windowInset + cabinWidth * 0.3, cabinY + windowInset);
    ctx.lineTo(cabinX + windowInset, cabinY + windowHeight);
    ctx.lineTo(cabinX + windowInset + cabinWidth * 0.35, cabinY + windowHeight);
    ctx.lineTo(cabinX + windowInset + cabinWidth * 0.45, cabinY + windowInset);
    ctx.closePath();
    ctx.fill();

    // Side Window
    drawPixelRect(
      ctx,
      cabinX + cabinWidth * 0.45,
      cabinY + windowInset,
      cabinWidth * 0.5 - windowInset,
      windowHeight,
      carColors.CAR_WINDOW
    );

    // Pillars (A, B)
    drawPixelRect(
      ctx,
      cabinX + cabinWidth * 0.35,
      cabinY + windowInset,
      5,
      windowHeight,
      carColors.CAR_ROOF
    ); // B-Pillar

    // 4. Roof
    drawPixelRect(ctx, cabinX, cabinY - 5, cabinWidth, 5, carColors.CAR_ROOF);
    drawPixelRect(
      ctx,
      cabinX + 2,
      cabinY - 7,
      cabinWidth - 4,
      2,
      lightenDarkenColor(carColors.CAR_ROOF, 15)
    );

    // Headlights & Taillights (I.1.D)
    const lightSize = { w: 6, h: 4 };
    // Headlights
    const headlightY = bodyY + player.height * 0.25 + frontTiltOffset;
    if (player.headlightsOn) {
      drawPixelRect(
        ctx,
        carX + player.width - lightSize.w - 5,
        headlightY,
        lightSize.w,
        lightSize.h,
        carColors.CAR_HEADLIGHT_ON
      );
      // Optional light cone (very simple)
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = carColors.CAR_HEADLIGHT_ON;
      ctx.beginPath();
      ctx.moveTo(carX + player.width - 5, headlightY + lightSize.h / 2);
      ctx.lineTo(carX + player.width + 50, headlightY - 10);
      ctx.lineTo(carX + player.width + 50, headlightY + lightSize.h + 10);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
    } else {
      drawPixelRect(
        ctx,
        carX + player.width - lightSize.w - 5,
        headlightY,
        lightSize.w,
        lightSize.h,
        carColors.CAR_HEADLIGHT_OFF
      );
    }

    // Taillights
    const taillightY = bodyY + player.height * 0.25 + rearTiltOffset;
    let taillightColor = player.isBraking
      ? carColors.CAR_TAILLIGHT_BRAKE
      : carColors.CAR_TAILLIGHT_ON;
    if (!player.headlightsOn && !player.isBraking)
      taillightColor = carColors.CAR_TAILLIGHT_OFF;

    drawPixelRect(
      ctx,
      carX + 5,
      taillightY,
      lightSize.w,
      lightSize.h,
      taillightColor
    );
    if (
      (player.headlightsOn || player.isBraking) &&
      taillightColor !== carColors.CAR_TAILLIGHT_OFF
    ) {
      // Optional glow for taillights
      ctx.globalAlpha = 0.2;
      drawPixelRect(
        ctx,
        carX + 3,
        taillightY - 1,
        lightSize.w + 4,
        lightSize.h + 2,
        taillightColor
      );
      ctx.globalAlpha = 1.0;
    }

    if (Config.DEBUG_MODE) {
      ctx.strokeStyle = "lime";
      ctx.lineWidth = 1;
      ctx.strokeRect(
        Math.floor(carX),
        Math.floor(bodyY), // Use bodyY for debug rect
        player.width,
        player.height
      );
      ctx.fillStyle = "white";
      ctx.font = "12px Courier New";
      ctx.fillText(
        `Speed: ${player.currentSpeed.toFixed(2)}`,
        carX,
        bodyY - 25
      );
      ctx.fillText(`Tilt: ${player.tiltAngle.toFixed(3)}`, carX, bodyY - 10);
    }
  },
};


---
